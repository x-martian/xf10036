<!--
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) Microsoft Corporation, 2006.  All rights reserved.
//
/////////////////////////////////////////////////////////////////////////////
-->


<cc:SdkSinglePageViewer
  Name    ="_af94e26d_1955_41e9_a16a_22852654ac48"
  Tag     ="WPF Migration and Interoperation Architecture"
  xmlns:cc="clr-namespace:Microsoft.Windows.SdkViewer.Controls;assembly=SdkViewer"
  xmlns   ="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
  <!--///////////////////////////////////////////////////////////////////////////////// Copyright (C) Microsoft Corporation, 2006.  All rights reserved.///////////////////////////////////////////////////////////////////////////////-->
  <cc:SdkSinglePageViewer
    Name    ="_af94e26d_1955_41e9_a16a_22852654ac48"
    Tag     ="WPF Migration and Interoperation Architecture"
    xmlns:cc="clr-namespace:Microsoft.Windows.SdkViewer.Controls;assembly=SdkViewer"
    xmlns   ="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
    <FlowDocument xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run>Windows Presentation Foundation Migration and Interoperation Architecture</Run>

              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run Foreground="DarkGray">[The content included in this documentation is a sub-set of the Windows SDK, and may not be complete or current. Please see the online Windows SDK for current documentation.]</Run>

      </Paragraph>

      <Paragraph/>
      <Paragraph>This article discusses interoperation between Windows Presentation Foundation and Win32-based components or applications. It also includes some practical code examples.    
      </Paragraph>

      <Paragraph>Nick Kramer    
      </Paragraph>

      <Paragraph>Program Manager    
      </Paragraph>

      <Paragraph>Microsoft Corporation    
      </Paragraph>

      <Paragraph>With Windows Presentation Foundation, you can do all sorts of things that aren’t possible or practical in Microsoft Win32. But what if you have an existing Win32 code base--do you need to throw it all away in order to use Windows Presentation Foundation? Happily, you don’t, because Windows Presentation Foundation can interoperate with your existing hwnd-based Win32 code. You can put Windows Presentation Foundation inside of hwnds, hwnds inside of Windows Presentation Foundation, and even use “nested interop” like Windows Presentation Foundation inside hwnds inside more Windows Presentation Foundation inside more hwnds! And because hwnds are used in a lot of different technologies – including Microsoft Foundation Classes (MFC), Active Template Library (ATL), Microsoft DirectX, and Microsoft ActiveX – Windows Presentation Foundation can interoperate with all of them.    
      </Paragraph>

      <Paragraph FontSize="22">HwndSource and HwndHost    
      </Paragraph>

      <Paragraph>To put Windows Presentation Foundation inside of a parent hwnd, one uses the HwndSource class to get an hwnd for the Windows Presentation Foundation content. As with all .NET APIs, you can use your choice of languages;I’ll use C++ to demonstrate <Run FontWeight="Bold">HwndSource</Run>
:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>UIElement^ wpfPage = gcnew MyWPFPage(); 
HwndSource^ source = gcnew HwndSource( 0, // class style WS_VISIBLE | WS_CHILD, // window style 0, // exstyle x, y, width, height, "my Windows Presentation Framework page", // NAME IntPtr(parent) // parent window ); 
source->RootVisual = wpfPage;HWND wpfHwnd = (HWND) source->Handle.ToPointer();</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>To put hwnds inside of Windows Presentation Foundation, use the HwndHost class. In C++, this looks like:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>public ref class MyHwndHost : HwndHost { protected: virtual HandleRef BuildWindowCore(HandleRef hwndParent) override { HWND handle = CreateWindowEx(0, L"LISTBOX", L"this is a Win32 listbox", WS_CHILD | WS_VISIBLE | LBS_NOTIFY | WS_VSCROLL | WS_BORDER, 0, 0, // x, y 30, 70, // height, width (HWND) hwndParent.Handle.ToPointer(), // parent hwnd 0, // hmenu 0, // hinstance 0); 
// lparam return HandleRef(this, IntPtr(handle)); 
} // dummy implementation of KeyboardInputSite property omitted };</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph FontSize="22">Managed and Unmanaged Code    
      </Paragraph>

      <Paragraph> APIs are managed code, but most existing Win32 programs are written in unmanaged C++. You can’t call Windows Presentation Foundation from a true unmanaged program, but by using the <Run FontWeight="Bold">/clr</Run>
 flag to the Microsoft Visual C++ compiler, you can create a mixed managed-unmanaged program where you can seamlessly mix managed and unmanaged API calls. The above examples mix managed APIs like <Run FontWeight="Bold">HwndHost</Run>
 and <Run>BuildWindowCore</Run>
 with unmanaged APIs like <Run>CreateWindowEx</Run>
. Just add /clr to your existing unmanaged project, recompile, and presto – instant managed code!    
      </Paragraph>

      <Paragraph>If you haven’t yet used Microsoft Visual C++ 2005, you’ll notice some new keywords like “gcnew” and “nullptr”;these supersede the older double-underscore syntax (like “__gc”) and make writing managed code in C++ a truly natural, “it just works” experience. You can learn more about the Microsoft Visual C++ 2005 managed features on <Hyperlink NavigateUri="http://msdn2.microsoft.com/library/xey702bw(en-us,vs.80).aspx">http://msdn2.microsoft.com/library/xey702bw(en-us,vs.80).aspx</Hyperlink>
.    
      </Paragraph>

      <Paragraph>There is one hitch, though, to using Windows Presentation Foundation and C++ together – you can’t compile Extensible Application Markup Language (XAML) files in a C++ project. There are a lot of different ways around this;my usual approach is to create a C# dll that contains my XAML pages, and have my C++ .exe include that dll. But there are other ways as well:    
      </Paragraph>

      <List MarkerStyle="Disc">
        <ListItem>
          <Paragraph>C# .exe and C++ .dll        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Use Load instead of compiling your XAML         
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Do not use XAML at all, write all your Windows Presentation Foundation in code        
          </Paragraph>

        </ListItem>

      </List>

      <Paragraph>Use whatever approach works best for you.    
      </Paragraph>

      <Paragraph FontSize="22">How Windows Presentation Framework Uses Hwnds    
      </Paragraph>

      <Paragraph>As you’ve seen, you can create some really powerful applications by using “hwnd interop” to mix Windows Presentation Foundation with other UI technologies. But to make the most of Windows Presentation Foundation’s “hwnd interop”, you need to understand how Windows Presentation Foundation uses hwnds. That’s because within a single HDC or HWND, you can't mix Windows Presentation Foundation rendering with DirectX rendering or GDI / rendering. So WM_PAINT either goes to GDI or to Windows Presentation Foundation, but not to both. This has a number of implications, including the so-called "airspace" restrictions, which brings us to how Windows Presentation Foundation uses hwnds under the hood.    
      </Paragraph>

      <Paragraph>All Windows Presentation Foundation elements on the screen are ultimately backed by hwnds. When you create a Windows Presentation Foundation Window, Windows Presentation Foundation creates a top-level hwnd, and uses an <Run FontWeight="Bold">HwndSource</Run>
 to put the <Run FontWeight="Bold">Window</Run>
's Windows Presentation Foundation content inside the hwnd. The rest of your Windows Presentation Foundation content in the application shares that one big hwnd. (Except for menus, combo box drop downs, and other pop-ups -- those create their own top-level window, which is why a Windows Presentation Foundation menu can go past the edge of the window containing it). And when you use <Run FontWeight="Bold">HwndHost</Run>
 to put an hwnd inside Windows Presentation Foundation, Windows Presentation Foundation tells Win32 how to position the new child hwnd relative to Windows Presentation Foundation <Run FontWeight="Bold">Window</Run>
's hwnd.    
      </Paragraph>

      <Paragraph>At the hwnd boundary, Windows Presentation Foundation has to play by Win32's rules. Which only make sense--ultimately someone needs to be in charge of determining who gets to draw on the screen, and where. So while Windows Presentation Foundation can do anything it wants inside that hwnd--make buttons rotate, support transparency from one Windows Presentation Foundation element to another, animate--Windows Presentation Foundation has to behave like an hwnd when it interacts with other hwnds. And Win32 has certain expectations, particularly "perfect clipping"--that any pixel of the hwnd that is visible on the screen can be rendered by painting that hwnd and not any hwnds underneath. So while Win32 supports some special cases of hwnd transparency, it doesn't support the general case, which requires rendering hwnds on the bottom before hwnds on the top.     
      </Paragraph>

      <Paragraph FontSize="22">Airspace    
      </Paragraph>

      <Paragraph>Now that we understand what's going on behind the scenes, let's describe some of the implications, which I refer to as "airspace". Within a top-level window, I like to think of each hwnd as having its own "airspace"--each pixel within the window belongs to exactly one hwnd, which constitutes that hwnd's airspace. And informally, I'll talk about the Windows Presentation Foundation airspace versus the DirectX airspace versus the Win32 airspace--although strictly speaking, there will be more than one Windows Presentation Foundation airspace if there's more than one Windows Presentation Foundation hwnd. I call it "airspace" because like air traffic control, bad things happen when you try to travel into someone else's airspace.    
      </Paragraph>

      <Paragraph>Let's walk through some examples. We'll start with an application that mixes Win32, DirectX, and Windows Presentation Foundation;since each technology gets its own separate, non-overlapping set of pixels, everyone is happy:    
      </Paragraph>

      <Paragraph>But suppose you take that same application and create an animation that flies over those three regions, in other words, that violates another's airspace. Which technology is drawing that animation? No matter what the answer, that technology violates someone else's airspace, so it can't be built. This is illustrated in the following picture, where the green circle is attempting to move around the window:    
      </Paragraph>

      <Paragraph>Another violation of airspace is when we use transparency/alpha blending between different technologies. In the picture below, the Windows Presentation Foundation box is violating Win32 and DirectX airspace -- because pixels are semi-transparent, they would have to be owned jointly by both DirectX and Windows Presentation Foundation, which is not possible. So this is another violation of airspace and can't be built:    
      </Paragraph>

      <Paragraph/>
      <Paragraph>The previous three examples used rectangular regions, but there's no reason that airspace has to be rectangular. It can be a rectangle with a hole (for example, Win32's airspace is everything except the Windows Presentation Foundation and DirectX airspace):    
      </Paragraph>

      <Paragraph>And airspaces can be completely nonrectangular, or any shape describable by a Win32 HRGN (region):    
      </Paragraph>

      <Paragraph FontSize="22">Hwnds Inside Windows Presentation Framework    
      </Paragraph>

      <Paragraph><Run FontWeight="Bold">HwndHost</Run>
 lets you put hwnds inside Windows Presentation Foundation – think of <Run FontWeight="Bold">HwndHost</Run>
 as a special control (technically, FrameworkElement) that hides the "hwnd-ness" from the rest of Windows Presentation Foundation. <Run FontWeight="Bold">HwndHost</Run>
 mostly behaves like any other FrameworkElement, although there are some important differences around output (drawing and graphics) and input (mouse and keyboard) stemming from limitations in what hwnds can do. Differences in output behavior include:     
      </Paragraph>

      <Paragraph>•<Run FontWeight="Bold">HwndHost</Run>
 cannot be rotated, scaled, skewed, or otherwise affected by a Transform.     
      </Paragraph>

      <Paragraph>•<Run FontWeight="Bold">HwndHost</Run>
 does not support the Opacity property (alpha blending). If content inside the <Run FontWeight="Bold">HwndHost</Run>
 does System.Drawing operations that include alpha, that's fine, but the <Run FontWeight="Bold">HwndHost</Run>
 as a whole only supports Opacity = 100% and can only be contained within other elements that are Opacity = 100%.     
      </Paragraph>

      <Paragraph>•<Run FontWeight="Bold">HwndHost</Run>
 will appear on top of other Windows Presentation Foundation elements in the same top-level window. (But note that menus, ToolTips, and combo box drop-downs are separate top-level windows, and so should work fine with <Run FontWeight="Bold">HwndHost</Run>
.) This is because multiple Windows Presentation Foundation elements share a single hwnd, and you can't say to Win32, "please put this hosted hwnd in front of only some parts of the Windows Presentation Foundation hwnd."    
      </Paragraph>

      <List MarkerStyle="Disc">
        <ListItem>
          <Paragraph><Run FontWeight="Bold">HwndHost</Run>
 does not respect the clipping region of its parent UIElement.         
          </Paragraph>

        </ListItem>

      </List>

      <Paragraph>Differences in input behavior include:     
      </Paragraph>

      <List MarkerStyle="Disc">
        <ListItem>
          <Paragraph>While the mouse is over the <Run FontWeight="Bold">HwndHost</Run>
, you won't receive Windows Presentation Foundation mouse events, and Windows Presentation Foundation's IsMouseOver property will return <Run FontWeight="Bold">false</Run>
.         
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>While the <Run FontWeight="Bold">HwndHost</Run>
 has keyboard focus, you won't receive Windows Presentation Foundation keyboard events and Windows Presentation Foundation's IsFocusWithin property will return <Run FontWeight="Bold">false</Run>
.         
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>When focus is within the <Run FontWeight="Bold">HwndHost</Run>
 and changes to another control inside the <Run FontWeight="Bold">HwndHost</Run>
, you won't receive Windows Presentation Foundation GotFocus/LostFocus events.        
          </Paragraph>

        </ListItem>

      </List>

      <Paragraph FontSize="22">Transparency and Top-Level Windows    
      </Paragraph>

      <Paragraph>The window manager (in both Windows Vista and Microsoft Windows XP) only understands HWNDs, so every Windows Presentation Foundation <Run FontWeight="Bold">Window</Run>
 is an hwnd. And it has to play by the rules that hwnds play by – inside that hwnd, Windows Presentation Foundation can do all sorts of unusual things, but when it comes to other hwnds on the desktop, Windows Presentation Foundation has to play by Win32 rules. Windows Presentation Foundation supports non-rectangular windows by using Win32 APIs -- HRGNs for non-rectangular windows and layered windows for a per-window alpha. Color transparency and transparency color keys are not currently supported;see below for more details. Win32 layered window capabilities vary by platform, which is covered below, but first a refresher on Win32 top-level windows.    
      </Paragraph>

      <Paragraph>In Win32, you can get a non-rectangular window two different ways. One way is by using a region (HRGN) to describe the shape of the window. The other is to use layered windows (WS_EX_LAYERED), which allow you to designate a certain color as being the “transparency key” and Win32 will make any pixels of that color completely transparent. So if you want a circular window, paint everything outside your circle with the transparency key color.    
      </Paragraph>

      <Paragraph>Layered windows also allow you to make the entire window translucent (semi-transparent) by specifying an alpha value to apply to every pixel in the window. (Win32 even supports per-pixel alpha, but this is very difficult to use in practical programs because in this mode you’ll need to draw any child hwnd yourself).    
      </Paragraph>

      <Paragraph>Windows Presentation Foundation supports HRGNs in all its variations;although there are no managed APIs for this functionality you can use PInvoke and <Run FontWeight="Bold">HwndSource</Run>
 to call the relevant APIs.     
      </Paragraph>

      <Paragraph>Windows Presentation Foundation layered windows have different capabilities on different operating systems (this stems from the fact that Windows Presentation Foundation uses DirectX to render–-layered windows were primarily designed for GDI rendering, not DirectX rendering):    
      </Paragraph>

      <List MarkerStyle="Disc">
        <ListItem>
          <Paragraph>Windows Presentation Foundation supports hardware accelerated layered windows on . Hardware accelerated layered windows on Microsoft Windows XP will be possible with an upcoming release of Microsoft DirectX.        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Windows Presentation Foundation doesn’t support transparency color keys, because Windows Presentation Foundation can't guarantee we render the exact color you asked for, particularly when hardware-accelerated.         
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>If running without the Windows Vista DWM (desktop window manager) enabled, layered windows on top of DirectX surfaces flicker when the DirectX application renders. (What is happening is Microsoft Windows Graphics Device Interface (GDI) hides the layered window, then lets DirectX draw, then puts the layered window back). Non-Windows Presentation Foundation layered windows also have this limitation.        
          </Paragraph>

        </ListItem>

      </List>

      <Paragraph FontSize="22">A Walkthrough of Windows Presentation Framework Inside Win32 (HwndSource)    
      </Paragraph>

      <Paragraph>To put Windows Presentation Foundation inside Win32 applications, use <Run FontWeight="Bold">HwndSource</Run>
, which provides an hwnd that contains your Windows Presentation Foundation content. <Run FontWeight="Bold">HwndSource</Run>
 is pretty straightforward to use – first you create the <Run FontWeight="Bold">HwndSource</Run>
, giving it parameters similar to CreateWindow. Then you tell the <Run FontWeight="Bold">HwndSource</Run>
 about the Windows Presentation Foundation content you want inside it. Finally, you get the hwnd out of the <Run FontWeight="Bold">HwndSource</Run>
.    
      </Paragraph>

      <Paragraph>Let’s demonstrate this by taking the Windows <Run FontWeight="Bold">Date and Time Properties</Run>
 dialog (which you get to buy double-clicking on the time in the lower right corner of the screen), and bring this dialog into the 21st century by replacing the Win32-style clock with a Windows Presentation Foundation clock.     
      </Paragraph>

      <Paragraph>We can recreate this by creating a plain old C++ Win32 project in Microsoft Visual Studio, and using the dialog editor to create the following:    
      </Paragraph>

      <Paragraph>(You don’t need to use Microsoft Visual Studio to use <Run FontWeight="Bold">HwndSource</Run>
, and you don’t need to use C++ to write Win32 programs, but this is a fairly typical way to do it).    
      </Paragraph>

      <Paragraph>We need to do five things to put a Windows Presentation Foundation clock into that dialog:    
      </Paragraph>

      <List MarkerStyle="Decimal">
        <ListItem>
          <Paragraph>Enable it to call managed code (/clr) by changing project settings in Microsoft Visual Studio        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Create a Windows Presentation Foundation Page in a separate DLL        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Put that Windows Presentation Foundation <Run FontWeight="Bold">Page</Run>
 inside an <Run FontWeight="Bold">HwndSource</Run>

          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Get an hwnd for that <Run FontWeight="Bold">Page</Run>
 using the Handle property        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Use Win32 to decide where to place the hwnd within the larger Win32 application        
          </Paragraph>

        </ListItem>

      </List>

      <Paragraph FontSize="22">/clr    
      </Paragraph>

      <Paragraph>The first step is to turn this unmanaged Win32 project into one that can call managed code. We need to tell the compiler to use /clr, link to the necessary DLLs we want to use, and decorate our Main method for use with Windows Presentation Foundation.    
      </Paragraph>

      <Paragraph>First, to enable the use of managed code inside our C++ project: Right-click on w32clock project and select "Properties". On the "General" property page (the default), change Common Language Runtime support to "/clr".    
      </Paragraph>

      <Paragraph>Next, add references to DLLs necessary for Windows Presentation Foundation: PresentationCore.dll, PresentationFramework.dll, System.dll, WindowsBase.dll, UIAutomationProvider.dll, and UIAutomationTypes.dll. (Following instructions assume the operating system is installed on C: drive.)    
      </Paragraph>

      <List MarkerStyle="Decimal">
        <ListItem>
          <Paragraph>Right-click on w32clock project and select "References...", and inside that dialog:        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Right-click on w32clock project and select "References...".         
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Click "Add New Reference," click Browse tab, enter C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\PresentationCore.dll, and click OK.        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Repeat for PresentationFramework.dll: C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\PresentationFramework.dll.        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Repeat for WindowsBase.dll: C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\WindowsBase.dll.        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Repeat for UIAutomationTypes.dll: C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\UIAutomationTypes.dll.        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Repeat for UIAutomationProvider.dll: C:\Program Files\Reference Assemblies\Microsoft\Framework\v3.0\UIAutomationProvider.dll.        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Click "Add New Reference," select System.dll, click OK.        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Click OK to exit the w32clock Property Pages for adding references.        
          </Paragraph>

        </ListItem>

      </List>

      <Paragraph>Finally, we add the <Run>STAThreadAttribute</Run>
 to our <Run>_tWinMain</Run>
 method for use with Windows Presentation Foundation:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>[System::STAThreadAttribute] int APIENTRY _tWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow)</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>This attribute tells the common language runtime (CLR) that when it initializes Component Object Model (COM), it should use a single threaded apartment model (STA), which is necessary for Windows Presentation Foundation (and Windows Forms).    
      </Paragraph>

      <Paragraph FontSize="18">Create a Windows Presentation Framework Page    
      </Paragraph>

      <Paragraph>Next, we create a DLL that defines a Windows Presentation Foundation <Run FontWeight="Bold">Page</Run>
. It’s often easiest to create the Windows Presentation Foundation <Run FontWeight="Bold">Page</Run>
 as a standalone application, and write and debug the Windows Presentation Foundation portion that way. Once done, that project can be turned into a DLL by right-clicking the project, clicking on Properties, going to the Application, and changing Output type to Windows Class Library.    
      </Paragraph>

      <Paragraph>The Windows Presentation Foundation dll project can then be combined with the Win32 project (one solution that contains two projects) – right-click on the solution, select Add\Existing Project.    
      </Paragraph>

      <Paragraph>To use that Windows Presentation Foundation dll from the Win32 project, we need to add a reference:    
      </Paragraph>

      <List MarkerStyle="Decimal">
        <ListItem>
          <Paragraph>Right-click on w32clock project and select "References...".         
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Click "Add New Reference."        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Click the "Projects" tab. Select WPFClock, click OK.        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Click OK to exit the w32clock Property Pages for adding references.        
          </Paragraph>

        </ListItem>

      </List>

      <Paragraph FontSize="18">HwndSource    
      </Paragraph>

      <Paragraph>Next, we use <Run FontWeight="Bold">HwndSource</Run>
 to make the Windows Presentation Foundation <Run FontWeight="Bold">Page</Run>
 look like an hwnd. We add this block of code to a C++ file:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>namespace ManagedCode { using namespace System;using namespace System::Windows;using namespace System::Windows::Interop;using namespace System::Windows::Media;HWND GetHwnd(HWND parent, int x, int y, int width, int height){ HwndSource^ source = gcnew HwndSource( 0, // class style WS_VISIBLE | WS_CHILD, // style 0, // exstyle x, y, width, height, "hi", // NAME IntPtr(parent) // parent window ); 
UIElement^ page = gcnew WPFClock::Clock(); 
source->RootVisual = page;return (HWND) source->Handle.ToPointer(); 
} } }</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Let’s discuss what each part does. The first part is a bunch of <Run FontStyle="italic">using</Run>
 clauses so that we don’t need to fully qualify all of our names:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>namespace ManagedCode { using namespace System;using namespace System::Windows;using namespace System::Windows::Interop;using namespace System::Windows::Media;</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Then we define a function that creates the Windows Presentation Foundation Page, puts an HwndSource around it, and returns the hwnd:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>HWND GetHwnd(HWND parent, int x, int y, int width, int height){</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>First it creates an <Run FontWeight="Bold">HwndSource</Run>
, whose parameters are similar to CreateWindow:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>HwndSource^ source = gcnew HwndSource( 0, // class style WS_VISIBLE | WS_CHILD, // style 0, // exstyle x, y, width, height, "hi", // NAME IntPtr(parent) // parent window );</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Then we create the Windows Presentation Foundation page by calling its constructor:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>UIElement^ page = gcnew WPFClock::Clock();</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>We then connect the page to the <Run FontWeight="Bold">HwndSource</Run>
:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>source->RootVisual = page;</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>And in the final line, return the hwnd for the <Run FontWeight="Bold">HwndSource</Run>
:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>return (HWND) source->Handle.ToPointer();</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph FontSize="18">Positioning the Hwnd    
      </Paragraph>

      <Paragraph>So now that we have an hwnd that contains the Windows Presentation Foundation clock, we need to put that hwnd inside the Win32 dialog. If we knew just where to put the hwnd, we would just pass that size and location to the <Run>GetHwnd</Run>
 function we defined earlier. But we used a resource file to define our dialog, so we aren’t exactly sure where any of the hwnds are positioned. So we use the Microsoft Visual Studio dialog editor to put a Win32 STATIC control where we want the clock to go (“Insert clock here”), and use that to position the Windows Presentation Foundation clock.    
      </Paragraph>

      <Paragraph>Where we handle WM_INITDIALOG, we use <Run>GetDlgItem</Run>
 to retrieve the hwnd for our placeholder STATIC:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>HWND placeholder = GetDlgItem(hDlg, IDC_CLOCK);</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>We then calculate the size and position of that placeholder STATIC, so we can put our Windows Presentation Foundation clock in that place:    
      </Paragraph>

      <Paragraph>RECT rectangle; 
   
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>GetWindowRect(placeholder, &rectangle); 
int width = rectangle.right - rectangle.left;int height = rectangle.bottom - rectangle.top;POINT point;point.x = rectangle.left;point.y = rectangle.top;result = MapWindowPoints(NULL, hDlg, &point, 1);</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Then we hide the placeholder STATIC:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>ShowWindow(placeholder, SW_HIDE);</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>And create the Windows Presentation Foundation clock hwnd in that location:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>HWND clock = ManagedCode::GetHwnd(hDlg, point.x, point.y, width, height);</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>The final result looks like:    
      </Paragraph>

      <Paragraph FontSize="22">A Walkthrough of Win32 Inside Windows Presentation Framework (HwndHost)    
      </Paragraph>

      <Paragraph>To reuse Win32 content inside Windows Presentation Foundation applications, use <Run FontWeight="Bold">HwndHost</Run>
, which is a control that makes hwnds look like Windows Presentation Foundation content. Like <Run FontWeight="Bold">HwndSource</Run>
, <Run FontWeight="Bold">HwndHost</Run>
 is straightforward to use – subclass <Run FontWeight="Bold">HwndHost</Run>
 and implement <Run>BuildWindowCore</Run>
 and <Run>DestroyWindowCore</Run>
 methods, then instantiate your <Run FontWeight="Bold">HwndHost</Run>
 subclass and put it inside your Windows Presentation Foundation application.    
      </Paragraph>

      <Paragraph>If your Win32 logic is already packaged up nicely as a control, then your <Run>BuildWindowCore</Run>
 implementation is little more than a call to <Run>CreateWindow</Run>
. For example, to create a Win32 LISTBOX control in C++:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>virtual HandleRef BuildWindowCore(HandleRef hwndParent) override { HWND handle = CreateWindowEx(0, L"LISTBOX", L"this is a Win32 listbox", WS_CHILD | WS_VISIBLE | LBS_NOTIFY | WS_VSCROLL | WS_BORDER, 0, 0, // x, y 30, 70, // height, width (HWND) hwndParent.Handle.ToPointer(), // parent hwnd 0, // hmenu 0, // hinstance 0); 
// lparam return HandleRef(this, IntPtr(handle)); 
} virtual void DestroyWindowCore(HandleRef hwnd) override { // HwndHost will dispose the hwnd for us }</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>But suppose the Win32 code is not quite so self-contained? Let’s take a Win32 dialog box and embed its contents into a larger Windows Presentation Foundation application. Again, we’ll do this in Microsoft Visual Studio and C++, although it’s also possible to do this in a different language or at the command line.    
      </Paragraph>

      <Paragraph>We’ll start with a simple dialog which is compiled into a C++ DLL project.    
      </Paragraph>

      <Paragraph>Here’s what we need to do to get that into our larger Windows Presentation Foundation application:    
      </Paragraph>

      <List MarkerStyle="Disc">
        <ListItem>
          <Paragraph>Compile the dll as managed (/clr)        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Turn the dialog into a control        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Define the subclass of <Run FontWeight="Bold">HwndHost</Run>
 with <Run>BuildWindowCore</Run>
 and <Run>DestroyWindowCore</Run>
 methods        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Implement <Run>KeyboardInputSite</Run>
 property to work around Visual C++ beta 2 bug        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Override <Run>TranslateAccelerator</Run>
 method to handle dialog keys        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Override <Run>TabInto</Run>
 method to support tabbing        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Override <Run>OnMnemonic</Run>
 method to support mnemonics        
          </Paragraph>

        </ListItem>

        <ListItem>
          <Paragraph>Instantiate our <Run FontWeight="Bold">HwndHost</Run>
 subclass and put it under the right Windows Presentation Foundation element        
          </Paragraph>

        </ListItem>

      </List>

      <Paragraph>In the previous section, we already covered how to turn an unmanaged C++ program into a managed C++ program using /clr, so we’ll skip right to the second step.    
      </Paragraph>

      <Paragraph FontSize="18">Turn the Dialog Into a Control    
      </Paragraph>

      <Paragraph>We can turn a dialog box into a child hwnd using the WS_CHILD and DS_CONTROL styles. Go into the resource file (.rc) where the dialog is defined, and find the beginning of the definition of the dialog:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>IDD_DIALOG1 DIALOGEX 0, 0, 303, 121 STYLE DS_SETFONT | DS_MODALFRAME | DS_FIXEDSYS | WS_POPUP | WS_CAPTION | WS_SYSMENU</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Change the second line to:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>STYLE DS_SETFONT | WS_CHILD | WS_BORDER | DS_CONTROL</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>That doesn’t fully package it into a self-contained control;we still need to call <Run>IsDialogMessage()</Run>
 so Win32 can process certain messages, but it does give us a straightforward way of putting those controls inside another hwnd.    
      </Paragraph>

      <Paragraph FontSize="22">Subclass HwndHost    
      </Paragraph>

      <Paragraph>We import the following namespaces:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>namespace ManagedCpp { using namespace System;using namespace System::Windows;using namespace System::Windows::Interop;using namespace System::Windows::Input;using namespace System::Windows::Media;using namespace System::Runtime::InteropServices;</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Then we create our own subclass of <Run FontWeight="Bold">HwndHost</Run>
 and override the <Run>BuildWindowCore</Run>
 and <Run>DestroyWindowCore</Run>
 methods:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>public ref class MyHwndHost : public HwndHost, IKeyboardInputSink { private: HWND dialog;protected: virtual HandleRef BuildWindowCore(HandleRef hwndParent) override { InitializeGlobals(); 
dialog = CreateDialog(hInstance, MAKEINTRESOURCE(IDD_DIALOG1), (HWND) hwndParent.Handle.ToPointer(), (DLGPROC) About); 
return HandleRef(this, IntPtr(dialog)); 
} virtual void DestroyWindowCore(HandleRef hwnd) override { // hwnd will be disposed for us }</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Here we use the <Run>CreateDialog</Run>
 to create our dialog box that’s really a control. Since this is one of the first methods that we call in our DLL, we also do some standard Win32 initialization by calling a function you'll write called <Run>InitializeGlobals()</Run>
:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>bool initialized = false;void InitializeGlobals(){ if (initialized) return;initialized = true;// TODO: Place code here. MSG msg;HACCEL hAccelTable;// Initialize global strings LoadString(hInstance, IDS_APP_TITLE, szTitle, MAX_LOADSTRING); 
LoadString(hInstance, IDC_TYPICALWIN32DIALOG, szWindowClass, MAX_LOADSTRING); 
MyRegisterClass(hInstance); 
</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph FontSize="18">Override TranslateAccelerator Method to Handle Dialog Keys    
      </Paragraph>

      <Paragraph>If we ran this sample now, we would get a dialog control that displays, but it would ignore all of the keyboard processing that makes a dialog box a dialog box. Let’s address that. Our first step is overriding the <Run>TranslateAccelerator</Run>
 implementation (which comes from <Run>IKeyboardInputSink</Run>
 – an interface that <Run FontWeight="Bold">HwndHost</Run>
 implements). This method gets called when the application receives WM_KEYDOWN and WM_SYSKEYDOWN.    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>#undef TranslateAccelerator virtual bool TranslateAccelerator(System::Windows::Interop::MSG% msg, ModifierKeys modifiers) override { ::MSG m = ConvertMessage(msg); 
// Win32's IsDialogMessage() will handle most of our tabbing, but doesn't know // what to do when it reaches the last tab stop if (m.message == WM_KEYDOWN &&m.wParam == VK_TAB){ HWND firstTabStop = GetDlgItem(dialog, IDC_EDIT1); 
HWND lastTabStop = GetDlgItem(dialog, IDCANCEL); 
TraversalRequest^ request = nullptr;if (GetKeyState(VK_SHIFT) &&GetFocus() == firstTabStop){ // this code should work, but there’s a bug with interop shift-tab in current builds request = gcnew TraversalRequest(FocusNavigationDirection::Last); 
} else if (!GetKeyState(VK_SHIFT) &&amp; 
GetFocus() == lastTabStop){ request = gcnew TraversalRequest(FocusNavigationDirection::Next); 
} if (request != nullptr) return ((IKeyboardInputSink^) this)->KeyboardInputSite->OnNoMoreTabStops(request); 
} // Only call IsDialogMessage for keys it will do something with. if (msg.message == WM_SYSKEYDOWN || msg.message == WM_KEYDOWN){ switch (m.wParam){ case VK_TAB: case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN: case VK_EXECUTE: case VK_RETURN: case VK_ESCAPE: case VK_CANCEL: IsDialogMessage(dialog, &m); 
// IsDialogMessage should be called ProcessDialogMessage -- // it processes messages without ever really telling you // if it handled a specific message or not return true;} } return false;// not a key we handled }</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>This is a big one so let’s break it into pieces. First, we’re using C++ and C++ macros;we need to be aware that there’s already a macro named <Run>TranslateAccelerator</Run>
, which is defined in winuser.h:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>#define TranslateAccelerator TranslateAcceleratorW</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>So we define a <Run>TranslateAccelerator</Run>
 method and not a <Run>TranslateAcceleratorW</Run>
 method.    
      </Paragraph>

      <Paragraph>Similarly, there’s both the unmanaged winuser.h MSG and the managed <Run>Microsoft::Win32::MSG</Run>
 struct. You can disambiguate between the two using C++’s :: operator.    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>virtual bool TranslateAccelerator(System::Windows::Interop::MSG% msg, ModifierKeys modifiers) override { ::MSG m = ConvertMessage(msg);</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Both MSGs have the same data, but sometimes it’s easier to work with the unmanaged definition, so in this sample we defined the obvious conversion routine:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>::MSG ConvertMessage(System::Windows::Interop::MSG% msg){ ::MSG m;m.hwnd = (HWND) msg.hwnd.ToPointer(); 
m.lParam = (LPARAM) msg.lParam.ToPointer(); 
m.message = msg.message;m.wParam = (WPARAM) msg.wParam.ToPointer(); 
m.time = msg.time;POINT pt;pt.x = msg.pt_x;pt.y = msg.pt_y;m.pt = pt;return m;}</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Back to <Run>TranslateAccelerator</Run>
. Our basic game plan is to call Win32’s <Run>IsDialogMessage</Run>
 to do as much work as possible, but <Run>IsDialogMessage</Run>
 doesn’t know about anything outside the dialog so we’ll have to help it with that. So as we tab around the dialog, when we run past the last control in our dialog we need to set focus to the Windows Presentation Foundation portion by calling <Run>IKeyboardInputSite::OnNoMoreStops</Run>
.    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>// Win32's IsDialogMessage() will handle most of our tabbing, but doesn't know // what to do when it reaches the last tab stop if (m.message == WM_KEYDOWN &&amp; 
m.wParam == VK_TAB){ HWND firstTabStop = GetDlgItem(dialog, IDC_EDIT1); 
HWND lastTabStop = GetDlgItem(dialog, IDCANCEL); 
TraversalRequest^ request = nullptr;if (GetKeyState(VK_SHIFT) &&amp; 
GetFocus() == firstTabStop){ // this code should work, but there’s a bug with interop shift-tab in current builds request = gcnew TraversalRequest(FocusNavigationDirection::Last); 
} else if (!GetKeyState(VK_SHIFT) &&amp; 
GetFocus() == lastTabStop){ { request = gcnew TraversalRequest(FocusNavigationDirection::Next); 
} if (request != nullptr) return ((IKeyboardInputSink^) this)->KeyboardInputSite->OnNoMoreTabStops(request); 
}</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Finally, we are ready to call <Run>IsDialogMessage</Run>
. But one of the responsibilities of a <Run>TranslateAccelerator</Run>
 method is telling Windows Presentation Foundation whether you handled the keystroke or not, so if you didn’t the input event can tunnel and bubble through the rest of the application. Unfortunately, <Run>IsDialogMessage</Run>
 doesn’t tell us whether it handles a particular keystroke. Even worse, it will call <Run>DispatchMessage()</Run>
 on keystrokes it shouldn’t handle! So we reverse-engineer <Run>IsDialogMessage</Run>
, and only call it for the keys we know it will handle:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>// Only call IsDialogMessage for keys it will do something with. if (msg.message == WM_SYSKEYDOWN || msg.message == WM_KEYDOWN){ switch (m.wParam){ case VK_TAB: case VK_LEFT: case VK_UP: case VK_RIGHT: case VK_DOWN: case VK_EXECUTE: case VK_RETURN: case VK_ESCAPE: case VK_CANCEL: IsDialogMessage(dialog, &m); 
// IsDialogMessage should be called ProcessDialogMessage -- // it processes messages without ever really telling you // if it handled a specific message or not return true;}</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph FontSize="18">Override TabInto Method to Support Tabbing    
      </Paragraph>

      <Paragraph>Now that we’ve implemented <Run>TranslateAccelerator</Run>
, we can tab around inside the dialog box and tab out of it into the greater Windows Presentation Foundation application. But we can’t tab back into the dialog box. To solve that, we override <Run>TabInto</Run>
:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>public: virtual bool TabInto(TraversalRequest^ request) override { if (request->FocusNavigationDirection == FocusNavigationDirection::Last){ HWND lastTabStop = GetDlgItem(dialog, IDCANCEL); 
SetFocus(lastTabStop); 
} else { HWND firstTabStop = GetDlgItem(dialog, IDC_EDIT1); 
SetFocus(firstTabStop); 
} return true;} </Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>The <Run>TraversalRequest</Run>
 parameter tells us whether it’s a tab or shift tab.    
      </Paragraph>

      <Paragraph FontSize="18">Override OnMnemonic Method to Support Mnemonics    
      </Paragraph>

      <Paragraph>Our keyboard handling is almost complete, but there’s one thing missing – mnemonics don’t work. If you press alt-F, focus doesn’t jump to the “First name:” edit box. And that’s where the <Run>OnMnemonic</Run>
 method comes in:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>virtual bool OnMnemonic(System::Windows::Interop::MSG% msg, ModifierKeys modifiers) override { ::MSG m = ConvertMessage(msg); 
// If it's one of our mnemonics, set focus to the appropriate hwnd if (msg.message == WM_SYSCHAR &&amp; 
GetKeyState(VK_MENU /*alt*/)){ int dialogitem = 9999;switch (m.wParam){ case 's': dialogitem = IDOK;break;case 'c': dialogitem = IDCANCEL;break;case 'f': dialogitem = IDC_EDIT1;break;case 'l': dialogitem = IDC_EDIT2;break;case 'p': dialogitem = IDC_EDIT3;break;case 'a': dialogitem = IDC_EDIT4;break;case 'i': dialogitem = IDC_EDIT5;break;case 't': dialogitem = IDC_EDIT6;break;case 'z': dialogitem = IDC_EDIT7;break;} if (dialogitem != 9999){ HWND hwnd = GetDlgItem(dialog, dialogitem); 
SetFocus(hwnd); 
return true;} } return false;// key unhandled };</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Why didn’t we call <Run>IsDialogMessage</Run>
 here? We have the same issue as before--we need to be able to tell Windows Presentation Foundation whether we handled the keystroke or not, and <Run>IsDialogMessage</Run>
 won’t do that. But there’s a second problem, because <Run>IsDialogMessage</Run>
 refuses to process the mnemonic if the focused hwnd isn’t inside the dialog box.    
      </Paragraph>

      <Paragraph FontSize="18">Instantiate the HwndHost Subclass    
      </Paragraph>

      <Paragraph>Finally, it’s time to put our <Run FontWeight="Bold">HwndHost</Run>
 into our larger Windows Presentation Foundation application. If the main application is written in XAML, the easiest way to put it in the right place is to leave an empty Border element where we want to put the <Run FontWeight="Bold">HwndHost</Run>
. Here we create a <Run FontWeight="Bold">Border</Run>
 named “insertHwndHostHere”:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>
&lt;Window x:Class="WPFApplication1.Window1" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="Windows Presentation Framework Application" Loaded="Window1_Loaded" > 
&lt;StackPanel> 
&lt;Button Content="WPF button"/> 
&lt;Border Name="insertHwndHostHere" Height="200" Width="500"/> 
&lt;Button Content="WPF button"/> 
&lt;/StackPanel> 
&lt;/Window></Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Then all that’s left is a good place to instantiate the <Run FontWeight="Bold">HwndHost</Run>
 and connect it to the <Run FontWeight="Bold">Border</Run>
. In our example, we’ll put it inside the constructor for our <Run FontWeight="Bold">Window</Run>
 subclass:    
      </Paragraph>

      <Table>
        <TableRowGroup>
          <TableRow>
            <TableCell>
              <Paragraph FontSize="22"><Run/>
              </Paragraph>

            </TableCell>

          </TableRow>

          <TableRow>
            <TableCell>
              <Paragraph TextAlignment="Left" FontSize="8pt" FontFamily="Courier New" xml:space="preserve"><Run>public partial class Window1 : Window { public Window1(){ } void Window1_Loaded(object sender, RoutedEventArgs e){ HwndHost host = new ManagedCpp.MyHwndHost(); 
insertHwndHostHere.Child = host;} }</Run>
            
              </Paragraph>

            </TableCell>

          </TableRow>

        </TableRowGroup>

      </Table>

      <Paragraph><Run/>
      </Paragraph>

      <Paragraph>Which gives us:    
      </Paragraph>

      <Paragraph FontSize="22">In Conclusion    
      </Paragraph>

      <Paragraph>You can build some wonderful programs using Windows Presentation Foundation and there’s no need to throw away your existing investment in Win32 technologies to leverage Windows Presentation Foundation. As we’ve seen, we can put hwnds inside Windows Presentation Foundation programs and we can put Windows Presentation Foundation code inside of hwnds, and even mixtures of those two, to create incredibly powerful programs that leverage your existing code. <Run FontWeight="Bold">HwndSource</Run>
, <Run FontWeight="Bold">HwndHost</Run>
, and IKeyboardInputSink make all of this possible.    
      </Paragraph>

      <Paragraph FontSize="16pt">About the author    
      </Paragraph>

      <Paragraph>Nick Kramer joined Microsoft in 1998 as a developer in Windows Forms. Today he is a program manager for a Windows Presentation Foundation subproject. Previously he was program manager on the Windows Client Platform team working on Windows Presentation Foundation, responsible for the Windows Presentation Foundation "element services" technologies, include the XAML parser, property engine and style system, interop, and input/commanding. After-hours he can be found in the great outdoors hiking, bicycling, or snowboarding. If you have questions about Windows Presentation Foundation and Windows Forms interop, you can contact Nick at nkramer@microsoft.com.    
      </Paragraph>

      <Paragraph/>
      <Paragraph/>
      <Paragraph><Span><Hyperlink NavigateUri="mailto:wsdkfdb@microsoft.com?subject=Feedback">Send comments</Hyperlink>
 about Windows Presentation Foundation Migration and Interoperation Architecture  to Microsoft. </Span>

      </Paragraph>

    </FlowDocument>

  </cc:SdkSinglePageViewer>

</cc:SdkSinglePageViewer>

