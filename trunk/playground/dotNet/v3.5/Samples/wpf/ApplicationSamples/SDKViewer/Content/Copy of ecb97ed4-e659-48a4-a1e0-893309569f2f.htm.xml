<cc:SdkSinglePageViewer xmlns:cc="clr-namespace:Microsoft.Windows.SdkViewer.Controls;assembly=SdkViewer" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
<FlowDocument xml:space="preserve" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"><Table><TableRowGroup>



<TableRow><TableCell><Paragraph FontSize="22"><Run>



Custom Control Case Study</Run></Paragraph></TableCell></TableRow><Paragraph /><Paragraph><Run Foreground="DarkGray">[This topic is pre-release documentation and is subject to change in future releases. Blank topics are included as placeholders.]</Run></Paragraph><Paragraph /><Paragraph>Kevin Moore</Paragraph><Paragraph>Windows Presentation Foundation </Paragraph><Paragraph>Microsoft Corporation</Paragraph><Paragraph>December 2005</Paragraph><Paragraph>Kevin Moore is a program manager (PM) in Windows Presentation Foundation working on component model.</Paragraph><Paragraph>My first task when I joined the Windows Presentation Foundation team in December 2004 was to build a color picker custom control. It was close to Christmas and many people were on vacation. I was told that building a custom control would be a good introduction to Windows Presentation Foundation. Because I was joining as a PM on the controls team, it seemed like a good idea. </Paragraph><Paragraph /><Paragraph>Since I was given no direction and little context in the "right way” to build a control in Windows Presentation Foundation, I went back to the thing with which I was most familiar: OnRender—OwnerDraw for Windows Presentation Foundation. To create my visuals, I was stuck with a primitive set of tools: line, brush, and rectangle. I also had to do a lot of heavy lifting with keyboard and mouse interaction. I was subclassing from Control, but I was not leveraging any of the functionality it provided. I was reinventing sliders and thumbs when this functionality already existed.</Paragraph><Paragraph /><Paragraph>Then I learned about the power of Windows Presentation Foundation composition and styling!</Paragraph><Paragraph /><Paragraph>With all that in mind, let’s revisit ColorPicker together and see if we can build it the "right way.”</Paragraph><Paragraph FontSize="22">Picking a Base Class</Paragraph><Paragraph>To be clear, there is nothing wrong with building a component in Windows Presentation Foundation using OnRender. Image is an excellent example of a control that “owns” its appearance and doesn’t need the ControlTemplate support provided by the Control class. If you want to build a component and you either don’t need or don’t care to support customized templates (or you want to provide your own mechanism for customization) then subclassing from FrameworkElement is appropriate. In fact, UserControl has been introduced to enable a developer to build a custom component from other elements in Windows Presentation Foundation without having to support templating. Despite its name, UserControl inherits from a FrameworkElement, not the Control class.</Paragraph><Paragraph /><Paragraph>When you decide to build a control, you are agreeing to provide mechanisms to allow customization of the visual tree through the Style and Template properties. Supporting styles and templates doesn’t come for free, but it drastically increases the scenarios in which your control can be used. If your control provides the right set of business logic, it can be styled to fit the look of the hosting application.</Paragraph><Paragraph /><Paragraph>Deciding you want to build a control does not limit your base class to only the Control class. There are a number of primitive classes provided in Windows Presentation Foundation to assist your control development. ItemsControl, for instance, provides services for displaying a set of data items. Menu, StatusBar, and TreeView leverage this base class. Selector builds on top of <Run FontWeight="Bold">ItemsControl</Run> to provide services for maintaining selection;
this is in turn leveraged by TabControl, ListBox, and ComboBox. In order to pick the right base class, you have to ask yourself two questions: </Paragraph><Paragraph /><List MarkerStyle="Decimal"><ListItem><Paragraph>What is the common developer experience (properties, events, methods) for my control? </Paragraph></ListItem><ListItem><Paragraph>What is the common user experience for my control? </Paragraph></ListItem></List><Paragraph /><Paragraph>A good way to answer these questions is to consider the value proposition of your control. What does it do that no other control can? Use this as a basis for the API that the control exposes--the developer experience--and the visualization and interactive behaviors of your control--the user experience.</Paragraph><Paragraph /><Paragraph>The developer experience is pretty straightforward for ColorPicker. At its most basic, we can imagine a control that exposes a color property of type Color. We probably also need a ColorChanged event with EventArgs that provide the old and new color.</Paragraph><Paragraph /><Paragraph>In the world of control styling, the user experience question is not as straightforward. What is the expected user experience for a ColorPicker? One could imagine a number of possible variations: three sliders for red, green, and blue;
a slider for hue with a gradient rectangle representing the saturation-brightness spectrum;
a list of possible colors the user can pick from;
a simple textbox that displays the hex value of the color.</Paragraph><Paragraph /><Paragraph>If you imagine a list of colors to pick from, you might be tempted to pick Selector<Run FontWeight="Bold" />as your base class. If you imagine an editable text field for the hex value, you might be inclined to pick TextBox.</Paragraph><Paragraph /><Paragraph>While I’m sure you will ask yourself “what functionality does this class provide that I need?” when you pick a base class, you should also ask “what functionality does this class provide that I don’t need?” The Selector class provides an Items property that is a collection of objects. Does it make sense to provide a collection of objects on ColorPicker? (Maybe a set of colors, but not objects.) Likewise, TextBox has a TextChanged event. Does this make sense for ColorPicker? You get the idea. For this sample, my notion of ColorPicker is that of a control with three sliders to pick red, green, and blue. Since we have no controls that abstract the selection of three non-discrete values, I’m going to start with Control as my base class. </Paragraph><Paragraph /><Paragraph>Keep in mind, though, that picking Control as a base class does not prohibit me from using a Selector or TextBox in the style. In fact, that kind of composition is encouraged and used extensively in the Windows Presentation Foundation Control Library. </Paragraph><Paragraph FontSize="22">Creating the ColorPicker Custom Control Project</Paragraph><Paragraph>To build a control Windows Presentation Foundation control that can be redistributed as a dynamic-link library (DLL), there are a few things we have to do:</Paragraph><Paragraph /><List MarkerStyle="Decimal"><ListItem><Paragraph>Create a project with an output type of "Library".</Paragraph></ListItem><ListItem><Paragraph>Add a ThemeInfo attribute to the assembly.</Paragraph></ListItem><ListItem><Paragraph>Add a Generic.XAML file to the project as a MarkupResource.</Paragraph></ListItem><ListItem><Paragraph>Override the DefaultStyleKeyProperty. </Paragraph></ListItem></List><Paragraph /><Paragraph>Thankfully, the Custom Control Library template does these things for you, but it’s important to understand what is required.</Paragraph><Paragraph FontSize="18">
Files for the project</Paragraph><List MarkerStyle="Disc"><ListItem><Paragraph>ColorPickerLib.csproj</Paragraph></ListItem><ListItem><Paragraph>ColorPicker.cs</Paragraph></ListItem><ListItem><Paragraph>themes\generic.xaml</Paragraph></ListItem><ListItem><Paragraph>Properties\AssembyInfo.cs</Paragraph></ListItem></List><Paragraph>The next section shows you how to create these files.</Paragraph><Paragraph FontSize="18">
Create a Custom Control Project</Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>In Microsoft Visual Studio, open the <Run FontWeight="Bold">File</Run> menu, select <Run FontWeight="Bold">New</Run>-&gt;




<Run FontWeight="Bold">Project</Run>.</Paragraph></ListItem><ListItem><Paragraph>Create a project named ColorPickerLib using the <Run FontWeight="Bold">WinFX Custom Control Library</Run> template.</Paragraph></ListItem><ListItem><Paragraph>By default the <Run FontWeight="Bold">WinFX Custom Control Library</Run> template added files to the project to create a <Run FontWeight="Bold">UserControl</Run>. <Run FontWeight="Bold">UserControl</Run> has no template support. We will be creating a custom control, which defines its visual appearance using templating. In the next few steps you will add the ColorPicker custom control class and remove <Run FontWeight="Bold">UserControl</Run> files.</Paragraph></ListItem><ListItem><Paragraph>In <Run FontWeight="Bold">Solution Explorer</Run> under ColorPickerLib project, right click on UserControl1.xaml and select <Run FontWeight="Bold">Delete</Run>. A warning dialog will appear. Click OK. Then right click on UserControl1.xaml.cs and select <Run FontWeight="Bold">Delete</Run>. Click OK on the warning dialog.</Paragraph></ListItem><ListItem><Paragraph>In <Run FontWeight="Bold">Solution Explorer</Run> right click on ColorPickerLib project, select <Run FontWeight="Bold">Add</Run>-&gt;




<Run FontWeight="Bold">New Item…</Run></Paragraph></ListItem><ListItem><Paragraph>In <Run FontWeight="Bold">Add New Item</Run> dialog select <Run FontWeight="Bold">WinFX Custom Control</Run> item template. Type ColorPicker.cs in the <Run FontWeight="Bold">Name</Run> box, and then click <Run FontWeight="Bold">Add</Run>.</Paragraph></ListItem><ListItem><Paragraph>In <Run FontWeight="Bold">Solution Explorer</Run>, navigate to the <Run FontWeight="Bold">Properties</Run> directory. Open the AssemblyInfo.cs file. Look at the ThemeInfo attribute in AssemblyInfo.cs. Your ThemeInfo attribute should look like the following:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>//This attribute describes where any theme specific and generic resource dictionaries can be found. [assembly: ThemeInfo(ResourceDictionaryLocation.None, ResourceDictionaryLocation.SourceAssembly)] </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph><Paragraph>If you specify theme or generic resources for types in your project assembly, you should add an assembly attribute to your project indicating where these resources are located. The first parameter specifies where theme specific resources are located and the second parameter specifies where generic resources are located (i.e. generic.xaml). </Paragraph><Paragraph>Possible values are - None (no resources), SourceAssembly (the resources are in the same assembly where the types are defined), and ExternalAssembly (an external assembly).</Paragraph></ListItem><ListItem><Paragraph>We won’t get into building the style for our control until we have some of the object model defined. Notice though that there is some placeholder code in generic.xaml and ColorPicker.cs already created for you.</Paragraph></ListItem></List><Paragraph FontSize="22">Create the ColorPicker Application Project</Paragraph><Paragraph>Our goal is to have a functioning control library, so we should create another application project in which to use our control. There are a number of samples that show what is needed in an Windows Presentation Foundation application.</Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>In <Run FontWeight="Bold">Solution Explorer</Run>, right click on ColorPickerLib solution.</Paragraph></ListItem><ListItem><Paragraph>Select <Run FontWeight="Bold">Add</Run>-&gt;




<Run FontWeight="Bold">New Project</Run>.</Paragraph></ListItem><ListItem><Paragraph>Create a project named ColorPickerApp using the <Run FontWeight="Bold">WinFX Windows Application</Run> project template.</Paragraph></ListItem></List><Paragraph>Once you have a functioning application project, you can add a reference to your ColorPicker like any other library. Accessing the control in code is the same as accessing any other library component. Referring to the external control in Extensible Application Markup Language (XAML) is slightly different.</Paragraph><Paragraph>The types you are introducing in your control are not part of the default Windows Presentation Foundation XML namespace. To make your class addressable in your application in Extensible Application Markup Language (XAML), you need to do the following:</Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>In the ColorPickerApp project, open Window1.xaml.</Paragraph></ListItem><ListItem><Paragraph>Add the <Run FontWeight="Bold">xmlns</Run> attribute to the Window element so it looks like the following:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



XAML </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Window x:Class="ColorPickerApp.Window1" xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="ColorPickerApp" xmlns:cp="clr-namespace:ColorPickerLib;assembly=ColorPickerLib"&gt;




 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>In the ColorPickerApp project, add a reference to ColorPickerLib by first navigating to ColorPickerApp -&gt;




 <Run FontWeight="Bold">Add References…</Run>. Then, in the <Run FontWeight="Bold">Add Reference</Run> dialog, select ColorPickerLib in the <Run FontWeight="Bold">Projects</Run> tab and click OK.</Paragraph></ListItem><ListItem><Paragraph>Create an instance of the ColorPicker by adding the following to the Grid element in Window.xaml:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



 </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;cp:ColorPicker Name="colorPicker" Background="Blue"/&gt;






</Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Set the ColorPickerApp project as the startup project by right-clicking on the ColorPickerApp project and then selecting <Run FontWeight="Bold">Set as StartUp Project</Run>.</Paragraph></ListItem><ListItem><Paragraph>Compile and run the application. It will display a blue background since that’s all that you've added to the ColorPicker control template so far. In the remainder of this lab we will modify the ColorPicker class and default style for ColorPicker to create the control.</Paragraph></ListItem></List><Paragraph>Now that we have the shell of our control defined, along with a test application, we can add functionality. Let’s start with properties.</Paragraph><Paragraph FontSize="22">Defining Properties</Paragraph><Paragraph>If you want to understand properties in Windows Presentation Foundation, you need to understand <Run>dependency property</Run> (DPs). Dependency properties are required to use databinding, styling, animation, default value support, inheritance, or invalidation in Windows Presentation Foundation. As a general rule, assume that most of the properties your control exposes are DPs unless you have a reason not to assume so. For more information on dependency properties in Windows Presentation Foundation, see <Hyperlink NavigateUri="d119d00c-3afb-48d6-87a0-c4da4f83dee5.htm.xaml.xaml">Properties Overview</Hyperlink>.</Paragraph><Paragraph /><Paragraph>For ColorPicker there is one obvious property: Color. Color has both a common language runtime (CLR) and dependency property. Add the following to the ColorPicker class in ColorPicker.cs:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



 </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public static DependencyProperty ColorProperty = DependencyProperty.Register( "Color", typeof(Color), typeof(ColorPicker), new PropertyMetadata(Colors.Black));
</Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public Color Color {

 get {

 return (Color)GetValue(ColorProperty);
 }
 set {

 SetValue(ColorProperty, value);
 }
 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph><Paragraph>If we didn’t care about styling support for ColorPicker, we’d probably be done. But, if you want your control to support styling, you have to think about stylability. A key piece of stylability is exposing properties that can be used by elements in a control template to interact with the object model of your control through binding and triggers. An example: using data binding, the IsExpanded property on TreeViewItem is linked to the IsPressed property of a ToggleButton in the <Run FontWeight="Bold">TreeViewItem</Run> style. The <Run FontWeight="Bold">ToggleButton</Run> is then styled to show a plus (+) when <Run FontWeight="Bold">IsPressed</Run> is <Run FontWeight="Bold">false</Run> and minus (-) when <Run FontWeight="Bold">IsPressed</Run> is <Run FontWeight="Bold">true</Run>. The Visibility of child items is also triggered in a <Run FontWeight="Bold">TreeViewItem</Run> by the IsEnabled property.</Paragraph><Paragraph /><Paragraph>Usually the properties exposed by your control, like <Run FontWeight="Bold">IsEnabled</Run>, make sense for both the style author and the control user. This is not always the case, though. MenuItem, for example, exposes a Role property. While this is of little use for a user of <Run FontWeight="Bold">MenuItem</Run>, it’s essential for someone styling <Run FontWeight="Bold">MenuItem</Run> to get the right visualization—a top-level menu looks considerably different than a nested menu, even though they are the same class.</Paragraph><Paragraph /><Paragraph>For ColorPicker we have a similar problem. Since Color is already defined, exposing individual red, green, and blue properties wouldn’t seem necessary. The ColorPicker style, however, will likely have individual sliders to manipulate the individual values. Since it’s not possible to bind to the separate values on the Color property, we need to expose them directly on ColorPicker.</Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>In the ColorPicker class, add the following code, which creates three dependency properties to set red, blue, and green colors.</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public static DependencyProperty RedProperty = DependencyProperty.Register( "Red", typeof(byte), typeof(ColorPicker));
 public static DependencyProperty GreenProperty = DependencyProperty.Register( "Green", typeof(byte), typeof(ColorPicker));
 public static DependencyProperty BlueProperty = DependencyProperty.Register( "Blue", typeof(byte), typeof(ColorPicker));
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Now, create the common language runtime (CLR) properties that correspond to the red, green, and blue dependency properties, as in the following example:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public byte Red {

 get {

 return (byte)GetValue(RedProperty);
 }
 set {

 SetValue(RedProperty, value);
 }
 }
 public byte Green {

 get {

 return (byte)GetValue(GreenProperty);
 }
 set {

 SetValue(GreenProperty, value);
 }
 }
 public byte Blue {

 get {

 return (byte)GetValue(BlueProperty);
 }
 set {

 SetValue(BlueProperty, value);
 }
 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem></List><Paragraph FontSize="18">
Create bindings between the Color property and the Red, Blue, and Green properties</Paragraph><Paragraph>The final task for the properties is to associate the individual color values to the main Color property. Changes in one should affect the others. Here we can leverage MultiBinding to keep these values in sync. For more information on data binding in Windows Presentation Foundation, see <Hyperlink NavigateUri="c707c95f-7811-401d-956e-2fffd019a211.htm.xaml.xaml">Data Binding Overview</Hyperlink>.</Paragraph><Paragraph /><List MarkerStyle="Decimal"><ListItem><Paragraph>Before we create the <Run FontWeight="Bold">MultiBinding</Run>, we need to create a converter which can serve as a proxy between the three individual color values and the main Color property. Define a ByteColorMultiConverter by adding the following class to ColorPicker.cs. Make sure you place this class outside of the existing ColorPicker class definition.</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public class ByteColorMultiConverter : IMultiValueConverter {

 public object Convert(object[] values, Type targetType, object parameter, System.Globalization.CultureInfo culture)
{


 if (values.Length != 3)
{


 throw new ArgumentException("need three values");
 }
 byte red = (byte)values[0];
byte green = (byte)values[1];
byte blue = (byte)values[2];
return Color.FromRgb(red, green, blue);
 }
 public object[] ConvertBack(object value, Type[] targetTypes, object parameter, System.Globalization.CultureInfo culture)
{


 Color color = (Color)value;
return new object[] {

 color.R, color.G, color.B }
;

}

 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Now that our converter is defined, we can define the binding. Add the following method to the ColorPicker class:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>private void SetupColorBindings()
{


 MultiBinding binding = new MultiBinding();
 binding.Converter = new ByteColorMultiConverter();
 binding.Mode = BindingMode.TwoWay;
Binding redBinding = new Binding("Red");
 redBinding.Source = this;
redBinding.Mode = BindingMode.TwoWay;
binding.Bindings.Add(redBinding);
 Binding greenBinding = new Binding("Green");
 greenBinding.Source = this;
greenBinding.Mode = BindingMode.TwoWay;
binding.Bindings.Add(greenBinding);
 Binding blueBinding = new Binding("Blue");
 blueBinding.Source = this;
blueBinding.Mode = BindingMode.TwoWay;
binding.Bindings.Add(blueBinding);
 this.SetBinding(ColorProperty, binding);
 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Add the following using directive for the MarkupExtension class in the SetupColorBindings method we just added:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>using System.Windows.Markup;
</Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>The default constructor in this control is a static constructor. In a static constructor you cannot create instance variables. Add an instance constructor for ColorPicker class to call SetupColorBindings, as in the following example:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



 </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public ColorPicker()
{


 SetupColorBindings();
 }
</Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem></List><Paragraph>At this point, if you compile and run your application, it should still display a blue background.</Paragraph><Paragraph FontSize="22">Building a Default Style</Paragraph><Paragraph>Let’s start by building up the elements that we want in our style, and then we will wire them up to the associated properties in the ColorPicker.</Paragraph><Paragraph FontSize="18">
Modify the ColorPicker style</Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>In generic.xaml, modify the ColorPicker's style so that it looks like the following:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



XAML </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Style TargetType="{

x:Type local:ColorPicker}
" x:Key="{

x:Type local:ColorPicker}
"&gt;




 
&lt;Setter Property="VerticalAlignment" Value="Center"/&gt;






 
&lt;Setter Property="HorizontalAlignment" Value="Center"/&gt;






 
&lt;Setter Property="Template"&gt;




 
&lt;Setter.Value&gt;




 
&lt;ControlTemplate TargetType="{

x:Type local:ColorPicker}
"&gt;




 
&lt;Grid&gt;




 
&lt;Grid.RowDefinitions&gt;




 
&lt;RowDefinition/&gt;






 
&lt;RowDefinition/&gt;






 
&lt;RowDefinition/&gt;






 
&lt;/Grid.RowDefinitions&gt;




 
&lt;Grid.ColumnDefinitions&gt;




 
&lt;ColumnDefinition/&gt;






 
&lt;ColumnDefinition/&gt;






 
&lt;ColumnDefinition/&gt;






 
&lt;ColumnDefinition/&gt;






 
&lt;/Grid.ColumnDefinitions&gt;




 
&lt;TextBlock Text="Red:" Grid.Row="0" Grid.Column="0" /&gt;






 
&lt;TextBlock Text="Green:" Grid.Row="1" Grid.Column="0"/&gt;






 
&lt;TextBlock Text="Blue:" Grid.Row="2" Grid.Column="0"/&gt;






 ...

 
&lt;TextBox Grid.Row="0" Grid.Column="2" Width="32" Text="{

Binding Path=Red, RelativeSource={

RelativeSource TemplatedParent}
}
" /&gt;






 
&lt;TextBox Grid.Row="1" Grid.Column="2" Width="32" Text="{

Binding Path=Green, RelativeSource={

RelativeSource TemplatedParent}
}
" /&gt;






 
&lt;TextBox Grid.Row="2" Grid.Column="2" Width="32" Text="{

Binding Path=Blue, RelativeSource={

RelativeSource TemplatedParent}
}
" /&gt;






 ...

 
&lt;/Grid&gt;




 
&lt;/ControlTemplate&gt;




 
&lt;/Setter.Value&gt;




 
&lt;/Setter&gt;




 
&lt;/Style&gt;




 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>In Window1.xaml of the ColorPickerApp project, modify the <Run FontWeight="Bold">Grid</Run> element so that it looks like the following:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



 </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Grid&gt;




 
&lt;StackPanel HorizontalAlignment="Left" Margin="20"&gt;




 
&lt;cp:ColorPicker Name="colorPicker" Red="20" Green="40" Blue="60"/&gt;






 
&lt;/StackPanel&gt;




 
&lt;/Grid&gt;




</Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>If you compile and run the application at this point, you will see that we have three text blocks to denote the color sliders and three text boxes to show the values for the colors. Note that the text boxes have been bound to Red, Green, and Blue respectively.</Paragraph></ListItem></List><Paragraph FontSize="18">
Add sliders to the control template</Paragraph><Paragraph>Now let's add sliders to our control. The sliders will replace the text boxes so that the end user can use the mouse to drag the slider to change the red, green, and blue values. </Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>Add a new style for Slider by inserting the following in generic.xaml. Be sure you add this outside of the ColorPicker style definition. You will use this new style in the control template for ColorPicker.</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



XAML </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Style x:Key="{

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
, ResourceId=ColorSliderStyle}
" TargetType="{

x:Type Slider}
"&gt;




 
&lt;Setter Property="Minimum" Value="0"/&gt;






 
&lt;Setter Property="Maximum" Value="255"/&gt;






 
&lt;Setter Property="SmallChange" Value="1"/&gt;






 
&lt;Setter Property="LargeChange" Value="51"/&gt;






 
&lt;Setter Property="IsMoveToPointEnabled" Value="true"/&gt;






 
&lt;Setter Property="Orientation" Value="Horizontal"/&gt;






 
&lt;/Style&gt;




 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>You may notice that the red, green, and blue properties are exposed as bytes on ColorPicker, but the Value property on <Run FontWeight="Bold">Slider</Run> is a double. We need a value converter to convert between the byte and the double. In ColorPicker.cs of the ColorPickerLib project, add the following class. Make sure you place this class outside of the existing ColorPicker class definition.</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public class ByteDoubleConverter : IValueConverter {

 public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
{


 return (double)(byte)value;

}

 public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
{


 return (byte)(double)value;

}

 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph><Paragraph>You may notice the value converter is as simple as defining a type cast from double to byte and vice-versa.</Paragraph></ListItem><ListItem><Paragraph>Now we can register the converter in our style and create our binding. Since the methods on the converter don’t require state, we only need one instance of the converter. We can add an instance of the converter to the resources. We also need to provide a key which is used to refer to the template. We need to define a ComponentResourceKey so that the hosting application knows where to find the converter. Add the following to generic.xaml:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



XAML </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;local:ByteDoubleConverter x:Key="{

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
, ResourceId=ByteDoubleConverter}
"/&gt;






 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>We just defined the ByteDoubleConverter once in our resources and gave it a key so that we can refer to it in other places in our style. Now we can use the converter to create a binding for the value property of the slider. The binding Path is set to the Red property of the ColorPicker. We set the Converter property to our instance of the ByteDoubleConverter by wrapping it in a StaticResource. Finally we set the RelativeSource of the Binding to TemplatedParent, which tells the binding where to look for the Red property. In generic.xaml, add the following to the <Run FontWeight="Bold">ControlTemplate</Run> of the ColorPicker style, between the TextBlock elements and the TextBox elements.</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



XAML </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Slider Grid.Row="0" Grid.Column="1" Style="{

StaticResource {

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
,ResourceId=ColorSliderStyle}
}
" Value="{

Binding Path=Red, Converter={

StaticResource {

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
, ResourceId=ByteDoubleConverter}
}
, RelativeSource={

RelativeSource TemplatedParent}
}
"/&gt;






 
&lt;Slider Grid.Row="1" Grid.Column="1" Style="{

StaticResource {

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
,ResourceId=ColorSliderStyle}
}
" Value="{

Binding Path=Green, Converter={

StaticResource {

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
, ResourceId=ByteDoubleConverter}
}
, RelativeSource={

RelativeSource TemplatedParent}
}
"/&gt;






 
&lt;Slider Grid.Row="2" Grid.Column="1" Style="{

StaticResource {

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
,ResourceId=ColorSliderStyle}
}
" Value="{

Binding Path=Blue, Converter={

StaticResource {

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
, ResourceId=ByteDoubleConverter}
}
, RelativeSource={

RelativeSource TemplatedParent}
}
"/&gt;






 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Compile and run the application. Your application should look like the following. To modify the red, green and blue value, the user can drag the sliders with the mouse or type into the text boxes.</Paragraph></ListItem></List><Paragraph FontSize="18">
Bind to the color property</Paragraph><Paragraph>Finally, we want to add a Rectangle to our control and wire the value of the Color property to the Fill property on the <Run FontWeight="Bold">Rectangle</Run>. We have a similar problem because Color is of type <Run FontWeight="Bold">Color</Run> and <Run FontWeight="Bold">Fill</Run> is of type Brush. We need another value converter to convert between the two.</Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>Add the following class in ColorPicker.cs in the ColorPickerLib project. In this scenario, we only provide a binding in one direction, so there is no need to convert <Run FontWeight="Bold">Brush</Run> back to <Run FontWeight="Bold">Color</Run>. So we are simply returning null in the ConvertBack method. Make sure you place this class outside of the existing ColorPicker class definition.</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>[ValueConversion(typeof(Color), typeof(SolidColorBrush))] public class ColorBrushConverter : IValueConverter {

 public object Convert(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
{


 Color color = (Color)value;
return new SolidColorBrush(color);
 }
 public object ConvertBack(object value, Type targetType, object parameter, System.Globalization.CultureInfo culture)
{


 return null;

}

 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Let’s wire it up in our style. First, we define the static resource. Add the following to the ResourceDictionary in generic.xaml.</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



XAML </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;local:ColorBrushConverter x:Key="{

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
, ResourceId=ColorBrushConverter}
"/&gt;






 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Then we add the binding. In generic.xaml, add the following to the control template of the ColorPicker style, after the bound text boxes. This adds a rectangle to our control template. The <Run FontWeight="Bold">Fill</Run> property of the control template is bound to the Color property of the ColorPicker. </Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



XAML </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Border BorderThickness="1" BorderBrush="Black" Grid.Row="0" Grid.Column="3" Grid.RowSpan="3"&gt;




 
&lt;Rectangle Width="50" Fill="{

Binding Path=Color, Converter={

StaticResource {

ComponentResourceKey TypeInTargetAssembly={

x:Type local:ColorPicker}
, ResourceId=ColorBrushConverter}
}
, RelativeSource={

RelativeSource TemplatedParent}
}
"/&gt;






 
&lt;/Border&gt;




 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Compile and run your application. There should now be a rectangle next to the three text boxes. Try moving the sliders or typing values in the text boxes to see how the fill of the rectangle changes color.</Paragraph></ListItem></List><Paragraph FontSize="22">Defining Events</Paragraph><Paragraph>Just as dependency properties in Windows Presentation Foundation extend the capabilities of standard common language runtime (CLR) properties, routed events extend the capabilities of CLR events. Routed events enable triggers in styles. Routed events also enable an event to propagate through the element tree within which any given element exists, rather than just being directed to one specific object. For more information about routed events in Windows Presentation Foundation, see <Hyperlink NavigateUri="1a2189ae-13b4-45b0-b12c-8de2e49c29d2.htm.xaml.xaml">Routed Events Overview</Hyperlink>.</Paragraph><Paragraph /><Paragraph>The same rule applies here: in general, expose a routed event for every event, unless you have a reason not to.</Paragraph><Paragraph /><Paragraph>Routed events have a RoutingStrategy that needs to be defined. In general, for controls, Bubble is the right way to go. Events that use the Tunnel <Run FontWeight="Bold">RoutingStrategy</Run> are used in the input system in Windows Presentation Foundation, but no tunneled events are defined in controls. Similarly, only a handful of Direct events are defined.</Paragraph><Paragraph FontSize="18">
Define the ColorChanged routed event</Paragraph><Paragraph>ColorPicker needs to define a single event: ColorChanged. Property changed events usually include the old and new value for the property. To limit the number of related event args that are needed, Windows Presentation Foundation has generic RoutedPropertyChangedEventArgs and RoutedPropertyChangedEventHandler classes that can be used for most changed events.</Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>Add the following to the ColorPicker class in ColorPicker.cs to register ColorChanged routed event:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public static readonly RoutedEvent ColorChangedEvent = EventManager.RegisterRoutedEvent("ColorChanged", RoutingStrategy.Bubble, typeof(RoutedPropertyChangedEventHandler
&lt;Color&gt;




), typeof(ColorPicker));
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Define a method to raise the ColorChanged routed event, as in the following example:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>protected virtual void OnColorChanged(Color oldValue, Color newValue)
{


 RoutedPropertyChangedEventArgs
&lt;Color&gt;




 args = new RoutedPropertyChangedEventArgs
&lt;Color&gt;




(oldValue, newValue);
 args.RoutedEvent = ColorPicker.ColorChangedEvent;
RaiseEvent(args);
 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Add the following lines to the ColorPicker class to add and remove the ColorChanged event:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public event RoutedPropertyChangedEventHandler
&lt;Color&gt;




 ColorChanged {

 add {

 AddHandler(ColorChangedEvent, value);
 }
 remove {

 RemoveHandler(ColorChangedEvent, value);
 }
 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem></List><Paragraph FontSize="18">
Add the property invalidated callback</Paragraph><Paragraph>Now we just need to fire the event when the Color property changes. Again, we can leverage the property system to help us out here. As part of the ColorProperty definition, we can include an invalidation callback. This is used whenever the Color property changes. To ensure that the changed event is only called when the value is actually different, instead of when it’s simply set to the current value, we create a cached value for Color that it can be compared to.</Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>The cache value is set in the constructor to the default value of the property and is refreshed in the invalidate callback once it is used to validate that a change occurred. Declare a variable to cache the value of the Color property by adding the following in the ColorPicker class.</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>private Color _colorCache;
</Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Change the PropertyMetadata in the Color dependency property registration to register a callback for PropertyInvalidation that is used to raise the ColorChanged event. You should change your dependency registration so it looks like the following:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public static DependencyProperty ColorProperty = DependencyProperty.Register( "Color", typeof(Color), typeof(ColorPicker), new PropertyMetadata(Colors.Black, new PropertyChangedCallback(OnColorInvalidated)));
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Add the following method to the ColorPicker class:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>private static void OnColorInvalidated(DependencyObject d, DependencyPropertyChangedEventArgs e)
{


 ColorPicker picker = (ColorPicker)d;
Color oldValue = (Color)e.OldValue;
Color newValue = (Color)e.NewValue;
picker.OnColorChanged(oldValue, newValue);
 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Set the _colorCache variable in the ColorPicker instance constructor. Your ColorPicker instance constructor should look like the following:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>public ColorPicker()
{


 _colorCache = (Color)ColorProperty.GetMetadata(this).DefaultValue;
SetupColorBindings();
 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem></List><Paragraph FontSize="18">
Create a ColorChanged event handler</Paragraph><Paragraph>To see how the ColorChanged event works, you can try these steps.</Paragraph><List MarkerStyle="Decimal"><ListItem><Paragraph>Add a ColorChanged event handler to the color picker. Also, add a TextBlock to display the new color value. Your StackPanel in Window1.xaml should look like that following:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



XAML </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;StackPanel HorizontalAlignment="Left" Margin="20"&gt;




 
&lt;cp:ColorPicker Name="colorPicker" ColorChanged="OnColorChanged"/&gt;






 
&lt;TextBlock Name="colorPickerValue"&gt;





&lt;/TextBlock&gt;




 
&lt;/StackPanel&gt;




 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Now implement the OnColorChanged event handler. Add the following code to Window1.xaml.cs:</Paragraph><Table><TableRowGroup><TableRow><TableCell><Paragraph FontSize="22"><Run>



C# </Run></Paragraph></TableCell></TableRow><TableRow><TableCell><Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>private void OnColorChanged(object sender, RoutedPropertyChangedEventArgs
&lt;Color&gt;




 e)
{


 colorPickerValue.Text = e.NewValue.ToString();
 }
 </Run></Paragraph></TableCell></TableRow></TableRowGroup></Table><Paragraph><Run /></Paragraph></ListItem><ListItem><Paragraph>Compile and run the application. You will see the text block you just added in XAML get updated with the new value of the Color property. Your application should look like the following:</Paragraph></ListItem></List><Paragraph FontSize="22">What's Next</Paragraph><Paragraph>You can find the examples in this article in the Color Picker Demo. In the Color Picker Demo, you will notice a custom style for the ColorPicker which is defined in the application. This demonstrates the goal of our control model: a control author bundles logic into a control which can then be easily customized by an application author to fit their needs.</Paragraph><Paragraph>Also take a look at <Hyperlink NavigateUri="e0df4f1e-8c07-4e86-89a3-e22acfffdc2a.htm.xaml.xaml">How to: Create a Custom Panel Element</Hyperlink> to learn about the two methods you have to override (MeasureOverride and ArrangeOverride) for your custom panel to work correctly.</Paragraph><Paragraph>Have fun building Windows Presentation Foundation controls!</Paragraph><Paragraph FontSize="22"><Run>See Also</Run></Paragraph><Paragraph FontSize="16pt">Concepts</Paragraph><Paragraph><Hyperlink NavigateUri="481765e5-5467-4a75-9f7b-e10e2ac410d9.htm.xaml.xaml">Styles Overview</Hyperlink><LineBreak /><Hyperlink NavigateUri="3d864748-cff0-4e63-9b23-d8e5a635b28f.htm.xaml.xaml">Control Authoring Overview</Hyperlink><LineBreak /></Paragraph><Paragraph FontSize="16pt">Other Resources</Paragraph><Paragraph>NumericUpDown Custom Control in an External Library Sample<LineBreak />NumericUpDown Custom Control with Theme and Automation Support Sample<LineBreak />Color Picker Demo<LineBreak />ColorPicker Custom Control Sample<LineBreak /><LineBreak /></Paragraph><Paragraph> </Paragraph><Paragraph /><Paragraph><Span><Hyperlink NavigateUri="mailto:wsdkfdb@microsoft.com?subject=Feedback">Send comments</Hyperlink> about ('Articles Documentation Feedback: ', 'Custom Control Case Study  to Microsoft. </Span></Paragraph></FlowDocument>
</cc:SdkSinglePageViewer>
