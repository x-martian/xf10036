<!--
/////////////////////////////////////////////////////////////////////////////
//
// Copyright (C) Microsoft Corporation, 2006.  All rights reserved.
//
/////////////////////////////////////////////////////////////////////////////
-->


<cc:SdkSinglePageViewer
  Name    ="_67cce290_ca26_4c41_a797_b68aabc45479"
  Tag     ="XAML Syntax Terminology"
  xmlns:cc="clr-namespace:Microsoft.Windows.SdkViewer.Controls;assembly=SdkViewer"
  xmlns   ="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
  <FlowDocument xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation">
    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML Syntax Terminology</Run>

            </Paragraph>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph>This topic defines the terms that are used to describe the elements of Extensible Application Markup Language (XAML) syntax. These terms are used frequently throughout the remainder of this software development kit (SDK). This topic expands on the basic terminology introduced in the <Hyperlink NavigateUri="a80db4cd-dd0f-479f-a45f-3740017c22e4.xaml">XAML Overview</Hyperlink>
.
    </Paragraph>

    <Paragraph>This topic contains the following sections.
    </Paragraph>

    <List MarkerStyle="Disc">
      <ListItem>
        <Paragraph><Hyperlink TargetName="Origin">Origin of XAML Syntax Terminology</Hyperlink>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Hyperlink TargetName="OESyntax">Object Element Syntax</Hyperlink>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Hyperlink TargetName="ASyntax">Attribute Syntax</Hyperlink>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Hyperlink TargetName="PESyntax">Property Element Syntax</Hyperlink>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Hyperlink TargetName="ContentSyntax">XAML Content Syntax</Hyperlink>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Hyperlink TargetName="AttachedProperties">Attached Properties</Hyperlink>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Hyperlink TargetName="AttachedEvents">Attached Events</Hyperlink>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Hyperlink TargetName="XmlNamespaces">Xml Namespaces</Hyperlink>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Hyperlink TargetName="MarkupExtensions">Markup Extensions</Hyperlink>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Run>Optional and Nonrecommended XAML Usages</Run>

        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph><Hyperlink TargetName="seeAlsoSection">Related Topics</Hyperlink>

        </Paragraph>

      </ListItem>

    </List>

    <Paragraph FontSize="22">Origin of XAML Syntax Terminology
    </Paragraph>

    <Paragraph>The XAML syntax terminology defined here is also defined or referenced within the XAML language specification. XAML is a language based on XML and follows XML structural rules. Some of the terminology is shared from or is based on the terminology commonly used when describing the XML language or the XML Document Object Model (DOM).
    </Paragraph>

    <Paragraph FontSize="22">Object Element Syntax
    </Paragraph>

    <Paragraph><Run FontStyle="italic">Object element syntax</Run>
 is the XAML markup syntax that instantiates a common language runtime (CLR) class or struct by declaring an XML element. This syntax resembles the element syntax of other markup languages such as HTML. Object element syntax begins with a left angle bracket (
&lt;), followed immediately by the type name of the class or struct being instantiated. Zero or more spaces can follow the type name, and zero or more attributes may also be declared on the object element, with one or more spaces separating each attribute name="value" pair. Finally, one of the following must be true:
    </Paragraph>

    <List MarkerStyle="Disc">
      <ListItem>
        <Paragraph>The element and tag must be closed by a forward slash (/) followed immediately by a right angle bracket (>).
        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph>The opening tag must be completed by a right angle bracket (>). Other object elements, property elements, or inner text, can follow the opening tag. Exactly what content may be contained here is typically constrained by the object model of the element; 
see Content Syntax section in this topic. The equivalent closing tag for the object element must also exist, in proper nesting and balance with other opening and closing tag pairs.
        </Paragraph>

      </ListItem>

    </List>

    <Paragraph>For example, the following example is object element syntax that instantiates a new instance of the Button class, and also specifies a Name attribute and a value for that attribute: 
    </Paragraph>

    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

        <TableRow>
          <TableCell>
            <Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Button Name="CheckoutButton"/> </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph>The following example is object element syntax that also includes Extensible Application Markup Language (XAML) content property syntax. The inner text contained within will be used to set the TextBox Extensible Application Markup Language (XAML) content property, Text.
    </Paragraph>

    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

        <TableRow>
          <TableCell>
            <Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;TextBox>This is a Text Box
&lt;/TextBox> </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph FontSize="22">Attribute Syntax
    </Paragraph>

    <Paragraph><Run FontStyle="italic">Attribute syntax</Run>
 is the XAML markup syntax that sets a value for a property, or names an event handlers for an event, by declaring an attribute on an element. The element is always declared through object element syntax. The attribute name must match the CLR member name of either a property or an event. The attribute name is followed by an assignment operator (=). The attribute value must be a string enclosed within two quotation marks (").
    </Paragraph>

    <Paragraph>In order to be set through attribute syntax, a property must be public, must be read-write, and must have a property value type that can be instantiated or referenced by a XAML loader. For events, the event must be public and have a public delegate. The property or event must be a member of the class or struct that is instantiated by the containing object element.
    </Paragraph>

    <Paragraph>The attribute value is filled by one of the following, using this processing order:
    </Paragraph>

    <List MarkerStyle="Decimal">
      <ListItem>
        <Paragraph>If the XAML loader encounters a curly brace, or an object element that derives from MarkupExtension, then the referenced markup extension is evaluated first rather than processing as a string, and the object returned by the markup extension is used. In many cases the object returned by a markup extension will be a reference to an existing object, or an expression that defers evaluation until runtime, and is not a new object.
        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph>If the property is declared with a designated TypeConverter, or the value type of that property is declared with an attributed <Run FontWeight="Bold">TypeConverter</Run>
, the string value of the attribute is submitted to the type converter as a conversion input, and the converter will return a new object instance.
        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph>If there is no <Run FontWeight="Bold">TypeConverter</Run>
, a direct conversion to the property type is attempted. This final level is a direct conversion between primitive types, or a check for names in an enumeration (which return the matching values).
        </Paragraph>

      </ListItem>

    </List>

    <Paragraph>For example, using the same markup as previously shown, the following example is the attribute syntax used to assign a string value for the <Run FontWeight="Bold">Name</Run>
 property:
    </Paragraph>

    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

        <TableRow>
          <TableCell>
            <Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Button Name="CheckoutButton"/> </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph>The <Run FontWeight="Bold">Name</Run>
 property is a member of the members table for the <Run FontWeight="Bold">Button</Run>
 class. <Run FontWeight="Bold">Button</Run>
 is a derived class of FrameworkElement class that defines <Run FontWeight="Bold">Name</Run>
.
    </Paragraph>

    <Paragraph FontSize="18">Processing of Attribute Values
    </Paragraph>

    <Paragraph>The string value contained within the opening and closing quotation marks is processed by a XAML loader. For properties, the default processing behavior is determined by the type of the underlying CLR property. If the property is a primitive type, then the attribute value is assigned based on implicit conversion of the string to the relevant primitive type. If the property is an enum, then the string is treated as a name defined by that enum and the matching value from the enum is returned. If the property is not a primitive type or enum, then the attribute value must be handled by a type converter that is declared on either the property itself or the destination type. The type converter must provide a conversion that accepts a string and must result in an instance of the type of the underlying CLR property. The conversion step might also be deferred through a markup extension .
    </Paragraph>

    <Paragraph FontSize="18">Property and Event Member Name References
    </Paragraph>

    <Paragraph>When specifying an attribute, you can reference any property or event that exists within the members table of the CLR type you instantiated for the containing object element.
    </Paragraph>

    <Paragraph>Or, you can reference an attached property or attached event, independent of the containing object element.
    </Paragraph>

    <Paragraph>You can also name any event from any object that is accessible through the default namespace by using a <Span FontWeight="Bold"><Run FontStyle="italic">typename</Run>
</Span>
.<Span FontWeight="Bold"><Run FontStyle="italic">event</Run>
</Span>
 partially qualified name; 
this syntax supports attaching handlers for <Run>routed events</Run>
 where the handler is intended to handle events routing from child elements, but the parent element does not also have that event in its members table. This syntax resembles an attached event syntax, but the event here is not a true attached event. Instead, you are referencing an event with a qualified name. For more information, see <Hyperlink NavigateUri="1a2189ae-13b4-45b0-b12c-8de2e49c29d2.xaml">Routed Events Overview</Hyperlink>
.
    </Paragraph>

    <Paragraph>Property names are sometimes provided as the value of an attribute, rather than the attribute name, and that property name can also include qualifiers. This scenario is common when writing styles or templates in XAML. However, the processing rules for property names provided as an attribute value are different, and are governed by the type of the property being set. That type is usually PropertyPath. For a more complete description of the lookup semantics, see <Hyperlink NavigateUri="0e3cdf07-abe6-460a-a9af-3764b4fd707f.xaml">PropertyPath XAML Syntax</Hyperlink>
.
    </Paragraph>

    <Paragraph FontSize="22">Property Element Syntax
    </Paragraph>

    <Paragraph><Run FontStyle="italic">Property element syntax</Run>
 is a syntax that diverges somewhat from the basic XML syntax. In XML, the value of an attribute is a de facto string, with the only possible variation being which string encoding format is being used other than UTF-8. In XAML, you can assign other object elements to be the value of a property. This capability is enabled by the property element syntax. Instead of the property being specified as an attribute within the element tag, the property is specified using an opening element tag in <Span FontWeight="Bold"><Run FontStyle="italic">typename.propertyname</Run>
</Span>
 form, the value of the property is specified, then the property element is closed.
    </Paragraph>

    <Paragraph>Specifically, the syntax begins with a left angle bracket (
&lt;), followed immediately by the type name of the class or struct that the property element syntax is contained within. This is followed immediately by a single dot (.), then by the name of a property that must exist within the members table of the specified type, then by a right angle bracket (>). The value to be assigned to the property is contained within the property element. Typically, the value is given as one or more object elements, because specifying objects as values is the scenario that property element syntax is intended to address. Finally, an equivalent closing tag specifying the same <Span FontWeight="Bold"><Run FontStyle="italic">typename.propertyname</Run>
</Span>
 combination must be provided, in proper nesting and balance with other element tags. For example, the following is property element syntax for the ContextMenu property of a <Run FontWeight="Bold">Button</Run>
.
    </Paragraph>

    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

        <TableRow>
          <TableCell>
            <Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Button> 
&lt;Button.ContextMenu> 
&lt;ContextMenu> 
&lt;MenuItem Header="1">First item
&lt;/MenuItem> 
&lt;MenuItem Header="2">Second item
&lt;/MenuItem> 
&lt;/ContextMenu> 
&lt;/Button.ContextMenu> Right-click me!
&lt;/Button> </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph>The value can also be given as inner text, but only if the property type being specified is a primitive value type, such as String, or enum where a name is specified. These two usages are uncommon, because each of these cases also supports attribute syntax. One scenario for filling a property element with a string is for properties that are not the XAML content property but still are used for representation of UI text, and particular whitespace elements such as linefeeds are required to appear in that UI text. Attribute syntax cannot preserve linefeeds, but property element syntax can, so long as significant whitespace preservation is active (for details, see <Hyperlink NavigateUri="cc9cc377-7544-4fd0-b65b-117b90bb0b23.xaml">Whitespace Processing in XAML</Hyperlink>
).
    </Paragraph>

    <Paragraph FontSize="18">Property Element Syntax for Collection Types
    </Paragraph>

    <Paragraph>The XAML specification requires XAML loader implementations to be able to identify properties where the value type is a collection. The WPF implementation is based on managed code, and its XAML loader identifies collection types through one of the following:
    </Paragraph>

    <List MarkerStyle="Disc">
      <ListItem>
        <Paragraph>Implements IList, or the generic equivalent (IList).
        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph>Implements IDictionary, or the generic equivalent (IDictionary).
        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph>Derives from Array (for more information about arrays in XAML, see <Hyperlink NavigateUri="c5358e14-d24c-44c7-b5eb-6062a4fd981c.xaml">x:Array Markup Extension</Hyperlink>
.)
        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph>Implements IAddChild (an interface defined by WPF).
        </Paragraph>

      </ListItem>

    </List>

    <Paragraph>If the type of a property is a collection, then the inferred collection type does not need to be specified in the markup. Instead, the elements that are intended to become the items in the collection are specified as one or more child elements of the collection type property element. Each such item is evaluated to an object during loading and added to the collection by calling the Add method of the implicit collection. For example, the Triggers property of Style takes the specialized collection type TriggerCollection. But it is not necessary to instantiate a <Run FontWeight="Bold">TriggerCollection</Run>
 in the markup. Instead, you specify one or more Trigger items as elements within the <Run>Style.Triggers</Run>
 property element, where <Run FontWeight="Bold">Trigger</Run>
 (or a derived class) is the type expected as the item type for the strongly typed and implicit <Run FontWeight="Bold">TriggerCollection</Run>
.
    </Paragraph>

    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

        <TableRow>
          <TableCell>
            <Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Style x:Key="SpecialButton" TargetType="{x:Type Button}"> 
&lt;Style.Triggers> 
&lt;Trigger Property="Button.IsMouseOver" Value="true"> 
&lt;Setter Property = "Background" Value="Red"/> 
&lt;/Trigger> 
&lt;Trigger Property="Button.IsPressed" Value="true"> 
&lt;Setter Property = "Foreground" Value="Green"/> 
&lt;/Trigger> 
&lt;/Style.Triggers> 
&lt;/Style> </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph>A property may be both a collection type, and the XAML content property for that type and derived types.
    </Paragraph>

    <Paragraph FontSize="22">XAML Content Syntax
    </Paragraph>

    <Paragraph>XAML content syntax is a syntax that is only enabled on classes that specify the ContentPropertyAttribute as part of their class declaration. The <Run FontWeight="Bold">ContentPropertyAttribute</Run>
 requires a parameter that specifies the property by name that is defined to be the content property for that type of element (including derived classes). The property thus designated is the XAML content property of an element. When processed by a XAML loader, any child elements or inner text that are found between the opening and closing tags of the element will be assigned to be the value of that XAML content property. Property element tags on an element are not assigned this way; 
they are processed first and are not considered to be "content".
    </Paragraph>

    <Paragraph>As with any other property, the XAML content property of an object will be of a specific type. That type can be the Object type. The type of that content property helps define the content model of an object. For instance, a type of <Run FontWeight="Bold">Object</Run>
 is loose in the sense that any object may become the content, but even this loose typing entails that the content must be a single object. The single object might be a collection object, but even so there can be only one such collection object assigned to be the content.
    </Paragraph>

    <Paragraph>Content models for particular types are described on the class pages for that type, or are written as separate conceptual topics for families of types and are linked to from each relevant type reference.
    </Paragraph>

    <Paragraph FontSize="18">Content Syntax for Collection Types
    </Paragraph>

    <Paragraph>In order to accept more than a single object element (or inner text) as content, the type of the content property must specifically be a collection type. Similar to property element syntax for collection types, a XAML loader must identify types that are collection types. If an element has a XAML content property, and the type of the XAML content property is a collection. The implied collection type does not need to be specified in the markup as an object element, and the XAML content property does not need to be specified as a property element. Therefore the apparent content model in the markup can now have more than one child element assigned as the content. The following is content syntax for a Panel subclass. All <Run FontWeight="Bold">Panel</Run>
 derived classes establish the XAML content property to be Children, which requires a value of type UIElementCollection. 
    </Paragraph>

    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

        <TableRow>
          <TableCell>
            <BlockUIContainer>
              <cc:SnippetViewer Name="_67cce290_ca26_4c41_a797_b68aabc45479_5">
                <cc:SnippetViewer.SnippetText>
&lt;Page xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" > 
&lt;StackPanel> 
&lt;Button>Button 1
&lt;/Button> 
&lt;Button>Button 2
&lt;/Button> 
&lt;Button>Button 3
&lt;/Button> 
&lt;/StackPanel> 
&lt;/Page> 
                </cc:SnippetViewer.SnippetText>
              </cc:SnippetViewer>

            </BlockUIContainer>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph>Note that neither the property element for <Run FontWeight="Bold">Children</Run>
 nor the element for the <Run FontWeight="Bold">UIElementCollection</Run>
 are required in the markup. This is a design feature of XAML so that recursively contained elements that define a UI are more intuitively represented as a tree of nested elements with immediate parent-child element relationships, without extraneous intervening property element tags or collection objects. In fact, <Run FontWeight="Bold">UIElementCollection</Run>
 cannot be specified in markup as an object element, by design. Because its only intended use is as an implicit collection, <Run FontWeight="Bold">UIElementCollection</Run>
 does not expose a public default constructor and thus cannot be instantiated as an object element.
    </Paragraph>

    <Paragraph FontSize="18">Mixing Property Elements and Object Elements in an Object with a Content Property
    </Paragraph>

    <Paragraph>The XAML specification declares that a XAML loader can enforce that object elements that are used to fill the XAML content property within an object element must be contiguous, and must not be mixed. This restriction against mixing property elements and content is enforced by the WPF XAML loader.
    </Paragraph>

    <Paragraph>You can have a child object element as the first immediate markup within an object element. Then you can introduce property elements. Or, you can specify one or more property elements, then content, then more property elements. But once a property element follows content, you cannot introduce any further content, only additional property elements.
    </Paragraph>

    <Paragraph>This content / property element order requirement does not apply to inner text used as content. However, it is still a good markup style to keep inner text contiguous, because significant whitespace will be difficult to detect visually in the markup if property elements are interspersed with inner text.
    </Paragraph>

    <Paragraph FontSize="22">Attached Properties
    </Paragraph>

    <Paragraph>Attached properties are a programming concept introduced in XAML whereby properties can be owned and defined by a type, but set on any element. The primary scenario that attached properties are intended for is to enable child elements in an element tree to report information to a parent element without requiring an extensively shared object model across all elements. Conversely, attached properties can be used by parent elements to report information to child elements. For more information on the purpose of attached properties and how to create your own attached properties, see <Hyperlink NavigateUri="75928354-dc01-47e8-a018-8409aec1f32d.xaml">Attached Properties Overview</Hyperlink>
.
    </Paragraph>

    <Paragraph>Attached properties use a syntax that superficially resembles property element syntax, in that you also specify a <Span FontWeight="Bold"><Run FontStyle="italic">typename.propertyname</Run>
</Span>
 combination. There are two important differences:
    </Paragraph>

    <List MarkerStyle="Disc">
      <ListItem>
        <Paragraph>You can use the <Span FontWeight="Bold"><Run FontStyle="italic">typename.propertyname</Run>
</Span>
 combination even when setting an attached property through attribute syntax. Attached properties are the only case where qualifying the property name is a requirement in an attribute syntax.
        </Paragraph>

      </ListItem>

      <ListItem>
        <Paragraph>You can also use property element syntax for attached properties. However, for typical property element syntax, the <Span FontWeight="Bold"><Run FontStyle="italic">typename</Run>
</Span>
 you specify is the object element that contains the property element. If you are referring to an attached property, then the <Span FontWeight="Bold"><Run FontStyle="italic">typename</Run>
</Span>
 is the class that defines the attached property, not the containing object element.
        </Paragraph>

      </ListItem>

    </List>

    <Paragraph FontSize="22">Attached Events
    </Paragraph>

    <Paragraph>Attached events are another programming concept introduced in XAML where events can be defined by a type, but handlers may be attached on any object. Often the type that defines an attached event is a static type that defines a service, and sometimes those attached events are exposed by a routed event alias in types that expose the service. Handlers for attached events are specified through attribute syntax. As with attached events, the attribute syntax is expanded for attached events to allow an <Span FontWeight="Bold"><Run FontStyle="italic">typename.eventname</Run>
</Span>
 usage, where <Span FontWeight="Bold"><Run FontStyle="italic">typename</Run>
</Span>
 is the class that provides Add and Remove event handler accessors for the attached event infrastructure, and <Span FontWeight="Bold"><Run FontStyle="italic">eventname</Run>
</Span>
 is the event name.
    </Paragraph>

    <Paragraph FontSize="22">Xml Namespaces
    </Paragraph>

    <Paragraph>None of the preceding syntax examples specified a namespace other than the default namespace. In typical WPF applications the default namespace is specified to be the WPF namespace. You can specify namespaces other than the default namespace and still use essentially the same kinds of syntax, but anywhere where a class is named that is not accessible within the default namespace, that class name must be preceded with the prefix of the XML namespace that was used to map the corresponding CLR namespace. For instance, <Run>
&lt;custom:MyElement/></Run>
 is object element syntax to instantiate an instance of the <Run>MyElement</Run>
 class, where the CLR namespace containing that class (and possibly the external assembly that contains that namespace) was previously mapped to the <Run>custom</Run>
 prefix.
    </Paragraph>

    <Paragraph>For more information about XML namespaces and XML, see <Hyperlink NavigateUri="5c0854e3-7470-435d-9fe2-93eec9d3634e.xaml">XAML Namespaces and Namespace Mapping</Hyperlink>
.
    </Paragraph>

    <Paragraph FontSize="22">Markup Extensions
    </Paragraph>

    <Paragraph>XAML defines a <Run FontStyle="italic">markup extension</Run>
 programming entity that enables an escape from the normal XAML loader processing of attributes or object elements, and defers the processing to a backing class. The WPF implementation of a XAML loader uses the <Run FontWeight="Bold">MarkupExtension</Run>
 abstract class as the basis for all of the markup extensions supported by WPF. The character that identifies a markup extension to a XAML loader when using attribute syntax is the opening curly brace ({), followed by any character other than a closing curly brace (}). The first string following the opening curly brace must reference the class that provides the particular extension behavior, where the reference may omit the substring "Extension" if that substring is part of the true class name. Thereafter, a single space may appear, and then each succeeding character is used as input by the extension implementation, up until the closing curly brace is encountered. The markup extensions in WPF are intended primarily to provide a means to reference other already-existing objects, or deferred references to objects that will be evaluated at runtime, while using attribute syntax. For instance, a simple data binding is accomplished by specifying the {Binding} markup extension in place of the value type that a given property would ordinarily take. Many of the markup extensions enable an attribute syntax for properties where an attribute syntax would not otherwise be possible. For instance, a <Run FontWeight="Bold">Style</Run>
 object is a relatively complex reference type that contains several other properties, each of which also take byref objects and not primitives. But styles are typically created as a resource, and then referenced through one of the two markup extensions that request a resource. The extension defers the evaluation of the property value to a resource lookup and enables providing the value of the Style property, taking type <Run FontWeight="Bold">Style</Run>
, in attribute syntax as follows:
    </Paragraph>

    <Paragraph><Run>
&lt;Button Style="{StaticResource MyStyle}">My button
&lt;/Button></Run>

    </Paragraph>

    <Paragraph>Here, <Run>StaticResource</Run>
 identifies the StaticResourceExtension class providing the markup extension implementation. The next string <Run>MyStyle</Run>
 is used as the input for the nondefault <Run FontWeight="Bold">StaticResourceExtension</Run>
 constructor, where the parameter as taken from the extension string declares the requested ResourceKey. <Run>MyStyle</Run>
 is expected to be the <Hyperlink NavigateUri="1985cd45-f197-42d5-b75e-886add64b248.xaml">x:Key Attribute</Hyperlink>
 value of a <Run FontWeight="Bold">Style</Run>
 defined as a resource. The <Hyperlink NavigateUri="97af044c-71f1-4617-9a94-9064b68185d2.xaml">StaticResource Markup Extension</Hyperlink>
 usage requests that the resource be used to provide the <Run FontWeight="Bold">Style</Run>
 property value through static resource lookup logic at compile time.
    </Paragraph>

    <Paragraph>For more information about markup extensions, see <Hyperlink NavigateUri="618dc745-8b14-4886-833f-486d2254bb78.xaml">Markup Extensions and XAML</Hyperlink>
. For a reference of markup extensions and other XAML programming features, see <Hyperlink NavigateUri="e1f47225-9996-4fbf-ab86-62d2e955f3fc.xaml">XAML Namespace (x:) Language Features</Hyperlink>
 and <Hyperlink NavigateUri="5e1d60e8-9403-47d0-98e4-b49aec871ee7.xaml">WPF Namespace XAML Extensions</Hyperlink>
. 
    </Paragraph>

    <Paragraph FontSize="22">Optional and Nonrecommended XAML Usages
    </Paragraph>

    <Paragraph FontSize="18">Optional Property Element Usages
    </Paragraph>

    <Paragraph>Optional property element usages include being specific about "spelling out" element content properties that the XAML loader considers implicit. For example, when you declare the contents of a Menu, you could choose to explicitly declare the Items collection of the <Run FontWeight="Bold">Menu</Run>
 as a <Run>
&lt;Menu.Items></Run>
 property element tag, and place each MenuItem within <Run>
&lt;Menu.Items></Run>
, rather than using the implicit XAML loader behavior that all child elements of a <Run FontWeight="Bold">Menu</Run>
 must be a <Run FontWeight="Bold">MenuItem</Run>
 and are placed in the <Run FontWeight="Bold">Items</Run>
 collection. Sometimes the optional usages can help to visually clarify the object structure as represented in the markup. Or sometimes an explicit property element usage can avoid markup that is technically functional but visually confusing, such as nested markup extensions within an attribute value.
    </Paragraph>

    <Paragraph FontSize="18">Full typename.membername qualified attributes
    </Paragraph>

    <Paragraph><Span FontWeight="Bold"><Run FontStyle="italic">typename</Run>
</Span>
.<Span FontWeight="Bold"><Run FontStyle="italic">membername</Run>
</Span>
 form for an attribute actually works more universally than just the routed event case, but in other applications that form is superfluous and you should avoid it, if only for reasons of markup style and readability. In the following example, each of the three references to the Background attribute are completely equivalent:
    </Paragraph>

    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

        <TableRow>
          <TableCell>
            <Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Button Background="Blue">Background
&lt;/Button> 
&lt;Button Button.Background="Blue">Button.Background
&lt;/Button> 
&lt;Button Control.Background="Blue">Control.Background
&lt;/Button> </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph><Run>Button.Background</Run>
 works because the qualified lookup for that property on <Run FontWeight="Bold">Button</Run>
 is successful (<Run FontWeight="Bold">Background</Run>
 was inherited from Control) and <Run FontWeight="Bold">Button</Run>
 is the class of the object element or a base class. <Run>Control.Background</Run>
 works because the Control class actually defines <Run FontWeight="Bold">Background</Run>
 and <Run FontWeight="Bold">Control</Run>
 is a <Run FontWeight="Bold">Button</Run>
 base class.
    </Paragraph>

    <Paragraph>However, the following <Span FontWeight="Bold"><Run FontStyle="italic">typename</Run>
</Span>
.<Span FontWeight="Bold"><Run FontStyle="italic">membername</Run>
</Span>
 form example does not work and is thus shown commented:
    </Paragraph>

    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

        <TableRow>
          <TableCell>
            <Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;!--
&lt;Button Label.Background="Blue">Does not work
&lt;/Button> --> </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph>Label is another derived class of <Run FontWeight="Bold">Control</Run>
, and if you had specified <Run>Label.Background</Run>
 within a <Run FontWeight="Bold">Label</Run>
 object element, this usage would have worked. However, because <Run FontWeight="Bold">Label</Run>
 is not the class or base class of <Run FontWeight="Bold">Button</Run>
, the specified XAML loader behavior is to then process<Run>Label.Background</Run>
 as an attached property. <Run>Label.Background</Run>
 is not an attached property, and this usage fails.
    </Paragraph>

    <Paragraph FontSize="18">basetypename.membername Property Elements
    </Paragraph>

    <Paragraph>In an analogous way to how <Span FontWeight="Bold"><Run FontStyle="italic">typename</Run>
</Span>
.<Span FontWeight="Bold"><Run FontStyle="italic">membername</Run>
</Span>
 form works for attribute syntax, a <Span FontWeight="Bold"><Run FontStyle="italic">basetypename</Run>
</Span>
.<Span FontWeight="Bold"><Run FontStyle="italic">membername</Run>
</Span>
 syntax works for property element syntax. For instance, the following syntax works:
    </Paragraph>

    <Table CellSpacing="5">
      <TableRowGroup>
        <TableRow>
          <TableCell>
            <Paragraph FontSize="22"><Run>XAML </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

        <TableRow>
          <TableCell>
            <Paragraph xml:space="preserve" TextAlignment="Left" FontSize="8pt" FontFamily="Courier New"><Run>
&lt;Button>Control.Background PE 
&lt;Control.Background> 
&lt;LinearGradientBrush StartPoint="0,0" EndPoint="1,1"> 
&lt;GradientStop Color="Yellow" Offset="0.0" /> 
&lt;GradientStop Color="LimeGreen" Offset="1.0" /> 
&lt;/LinearGradientBrush> 
&lt;/Control.Background> 
&lt;/Button> </Run>

            </Paragraph>

          </TableCell>

        </TableRow>

      </TableRowGroup>

    </Table>

    <Paragraph>Here, the property element was given as <Run>Control.Background</Run>
 even though the property element was contained in <Run>Button</Run>
.
    </Paragraph>

    <Paragraph>But just like <Span FontWeight="Bold"><Run FontStyle="italic">typename</Run>
</Span>
.<Span FontWeight="Bold"><Run FontStyle="italic">membername</Run>
</Span>
 form for attributes, <Span FontWeight="Bold"><Run FontStyle="italic">basetypename</Run>
</Span>
.<Span FontWeight="Bold"><Run FontStyle="italic">membername</Run>
</Span>
 is poor style in markup, and you should avoid it for style reasons.
    </Paragraph>

    <Paragraph FontSize="22"><Run>See Also</Run>

    </Paragraph>

    <Paragraph FontSize="16pt">Concepts
    </Paragraph>

    <Paragraph><Hyperlink NavigateUri="a80db4cd-dd0f-479f-a45f-3740017c22e4.xaml">XAML Overview</Hyperlink>

      <LineBreak/><Hyperlink NavigateUri="d119d00c-3afb-48d6-87a0-c4da4f83dee5.xaml">Dependency Properties Overview</Hyperlink>

      <LineBreak/><Hyperlink NavigateUri="f6313e4d-e89d-497d-ac87-b43511a1ae4b.xaml">TypeConverters and XAML</Hyperlink>

      <LineBreak/><Hyperlink NavigateUri="e7313137-581e-4a64-8453-d44e15a6164a.xaml">XAML and Custom Classes</Hyperlink>

      <LineBreak/>
    </Paragraph>

    <Paragraph FontSize="16pt">Other Resources
    </Paragraph>

    <Paragraph><Hyperlink NavigateUri="e1f47225-9996-4fbf-ab86-62d2e955f3fc.xaml">XAML Namespace (x:) Language Features</Hyperlink>

      <LineBreak/><Hyperlink NavigateUri="5e1d60e8-9403-47d0-98e4-b49aec871ee7.xaml">WPF Namespace XAML Extensions</Hyperlink>

      <LineBreak/>
      <LineBreak/>
    </Paragraph>

    <Paragraph/>
    <Paragraph/>
    <Paragraph><Span><Hyperlink NavigateUri="mailto:wsdkfdb@microsoft.com?subject=Feedback">Send comments</Hyperlink>
 about XAML Syntax Terminology to Microsoft. </Span>

    </Paragraph>

  </FlowDocument>

</cc:SdkSinglePageViewer>

